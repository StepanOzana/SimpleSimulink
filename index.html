<!doctype html>
<html lang="en">
<head>
  <link rel="icon" href="/favicon.ico">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulink-lite (Plain HTML) - JointJS</title>

  <!-- JointJS (UMD, no build step) -->
  <link rel="stylesheet" href="/static/joint.css">
  <script src="/static/joint.js"></script>

  <!-- Plotly (kept as in your Drawflow version) -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    .layout { display: grid; grid-template-columns: 260px 1fr; height: 100vh; }
    .panel { border-right: 1px solid #ddd; padding: 12px; overflow: auto; }
    #paperWrap { width: 100%; height: 100%; background: #f6f7f9; outline: none; position: relative;  box-sizing: border-box; }
    .toolbar button { width: 100%; margin: 6px 0; padding: 10px; cursor: pointer; }
    .blockbtn { text-align: left; }
    .kv { display: grid; grid-template-columns: 70px 90px; gap: 8px; }
    .kv label { font-size: 12px; color: #555; }
    input[type="number"], input[type="text"] { width: 100%; padding: 6px; }
    pre { white-space: pre-wrap; word-break: break-word; background:#111; color:#ddd; padding:10px; border-radius:8px; }
    .hint { font-size: 12px; color:#666; line-height: 1.4; }

    /* Floating panels (Output + Plot) */
    .floating-panel {
      position: fixed;
      top: 60px;
      right: 18px;
      width: 360px;
      max-height: calc(100vh - 90px);
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.18);
      z-index: 9999;
      display: none;
      overflow: hidden;
    }
    .floating-panel.show { display: block; }

    .fp-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      cursor: move;
      user-select:none;
      background:#f3f4f6;
      border-bottom:1px solid #e5e7eb;
      font-weight:700;
    }
    .fp-header .fp-actions{ display:flex; gap:8px; }
    .fp-btn{
      border:1px solid #d1d5db;
      background:#fff;
      border-radius:10px;
      padding:6px 10px;
      cursor:pointer;
      font-weight:600;
    }
    .fp-btn:hover{ background:#f9fafb; }

    .fp-body{
      padding:12px;
      overflow:auto;
      max-height: calc(100vh - 150px);
    }

    /* Plot window is wider */
    #plotWindow.floating-panel{ width: 560px; }
    #plotCanvas{ height: 360px; }

    /* Left panel selection editor */
    .section-title{ margin: 14px 0 8px; font-size: 14px; font-weight: 800; }

    /* Collapsible block categories */
    .blockcats details.cat { margin: 6px 0; }
    .blockcats details.cat summary { cursor: pointer; user-select: none; font-weight: 600; }
    .blockcats details.cat summary::-webkit-details-marker { display: none; }
    .blockcats details.cat summary::before { content: "‚ñæ"; display: inline-block; width: 18px; }
    .blockcats details.cat:not([open]) summary::before { content: "‚ñ∏"; }
    .blockcats details.cat .toolbar { margin-top: 6px; }

    /* JointJS paper tweaks */
    #paperWrap .joint-paper { background: transparent !important; }
    /* Make ports sit above links */
    .joint-port-body { pointer-events: all; }

  
/* === UX: small crosshair cursor on ports / nodes === */
.joint-port,
.joint-port * {
    cursor: crosshair !important;
}

.joint-element {
    cursor: default;
}

.joint-element .joint-port {
    cursor: crosshair;
}


/* Ensure the larger invisible port hit area can capture pointer events */
.joint-port-hit { pointer-events: all; }


/* Keep port hit-ring invisible even when JointJS applies magnet highlighting */
.joint-port-hit,
.joint-port-hit * {
    stroke: transparent !important;
    fill: none !important;
}


/* === Selected block highlight (backup CSS if needed) === */
.joint-cell.selected-block rect,
.joint-cell.selected-block .body {
  stroke: #8b5cf6 !important;
  stroke-width: 3 !important;
  fill: #f5f3ff !important;
}


/* === Box selection rectangle === */
#paperWrap .box-select-rect{
  position:absolute;
  border:1px dashed #8b5cf6;
  background: rgba(139, 92, 246, 0.10);
  pointer-events:none;
  z-index: 10000;
}


    /* === UI Tabs (left panel) === */
    .ltabs{ display:flex; gap:6px; margin:8px 0 10px; }
    .ltab{ flex:1; border:1px solid #d1d5db; background:#fff; border-radius:10px; padding:8px 10px; cursor:pointer; font-weight:700; }
    .ltab.active{ background:#f3f4f6; }
    .lsection{ display:none; }
    .lsection.show{ display:block; }

    /* === Scheme tabs (top of canvas) === */
    #paperWrap{ position:relative; }
    #schemeTabs{
      position:absolute;
      left:0; right:0; top:0;
      height:36px;
      display:flex;
      align-items:center;
      gap:6px;
      padding:6px 8px;
      background: rgba(255,255,255,0.92);
      border-bottom:1px solid #e5e7eb;
      z-index: 12000;
      box-sizing:border-box;
      backdrop-filter: blur(6px);
    }
    .stab{
      border:1px solid #d1d5db;
      background:#fff;
      border-radius:999px;
      padding:6px 10px;
      cursor:pointer;
      font-weight:700;
      font-size:12px;
      display:flex;
      align-items:center;
      gap:8px;
      max-width:180px;
    }
    .stab.active{ background:#eef2ff; border-color:#c7d2fe; }
    .stab .x{ font-weight:900; opacity:0.65; }
    .stab:hover .x{ opacity:0.95; }
    .stabAdd{ margin-left:auto; border-style:dashed; }
    #paperMount{ position:absolute; left:0; right:0; top:36px; bottom:0; }


    .copy-ghost{
      position:absolute;
      z-index:50;
      pointer-events:none;
      border:2px dashed #444;
      border-radius:12px;
      background:rgba(255,255,255,0.55);
      box-shadow:0 2px 10px rgba(0,0,0,0.18);
      user-select:none;

      display:flex;
      align-items:center;
      justify-content:center;
      font-size:12px;
      font-weight:700;

      transform: translate(-50%, -50%);
    }
    .copy-ghost .label{
      padding:4px 8px;
      background:rgba(255,255,255,0.75);
      border-radius:999px;
      border:1px solid rgba(0,0,0,0.15);
    }


  </style>
</head>
<body>
<div class="layout">
  <!-- Left panel -->
  <div class="panel">
    <h3>Project</h3>
<div class="ltabs">
  <button class="ltab active" data-tab="blocks" type="button">Blocks</button>
  <button class="ltab" data-tab="run" type="button">Run</button>
  <button class="ltab" data-tab="settings" type="button">Nastaven√≠</button>
</div>
<div id="tab_blocks" class="lsection show">
<h3>Blocks</h3>
    <div class="blockcats">
      <details class="cat">
        <summary>Sources</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('Constant')">+ Constant</button>
        </div>
      </details>

      <details class="cat">
        <summary>Math</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('Gain')">+ Gain</button>
          <button class="blockbtn" onclick="addBlock('Sum')">+ Sum (u1,u2)</button>
        </div>
      </details>

      <details class="cat">
        <summary>Models</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('TransferFunction')">+ Transfer Function</button>
          <button class="blockbtn" onclick="addBlock('Integrator')">+ Integrator</button>
        </div>
      </details>


      <details class="cat">
        <summary>Discontinuities</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('Saturation')">+ Saturation</button>
        </div>
      </details>

      <details class="cat">
        <summary>Sinks</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('Plot')">+ Plot</button>
          <button class="blockbtn" onclick="addBlock('Display')">+ Display</button>
        </div>
      </details>
    </div>

    </div>

    <div id="tab_run" class="lsection">
    <h3>Sch√©ma</h3>
    <button onclick="saveScheme()">üíæ Ulo≈æit sch√©ma</button>
    <input type="file" id="loadSchemeInput" accept="application/json" style="display:none" onchange="loadSchemeFromFile(event)">
    <button onclick="document.getElementById('loadSchemeInput').click()">üìÇ Otev≈ô√≠t sch√©ma</button>

    <hr>

    <h3>Run</h3>
    <div class="kv">
      <label>t0</label><input id="t0" type="number" value="0" step="0.1">
      <label>t1</label><input id="t1" type="number" value="5" step="0.1">
      <label>dt</label><input id="dt" type="number" value="0.1" step="0.01">
    </div>

    <div class="section-title">Selected block</div>
    <div id="selectedInfo" class="hint">Nothing selected.</div>
    <div id="paramEditor"></div>

    <button onclick="exportGraph()">Export JSON</button>
    <button onclick="simulate()">Simulate</button>
    <button id="toggleOutputBtn" style="margin-top:10px;" onclick="toggleOutput()">Show Output (F2)</button>


    <div id="tab_settings" class="lsection">
      <h3>Nastaven√≠ simulace</h3>
      <div class="kv">
        <label>Solver</label>
        <select id="solver" style="width:100%; padding:6px;">
          <option value="rk45">RK45 (solve_ivp)</option>
          <option value="rk4">RK4 (fixed-step)</option>
          <option value="rk2">RK2 / Heun (fixed-step)</option>
          <option value="euler">Euler (fixed-step)</option>
          <option value="radau">Radau (solve_ivp)</option>
          <option value="bdf">BDF (solve_ivp)</option>
        </select>
      </div>
      <div class="hint" style="margin-top:8px;">
        Pozn.: Fixed-step metody pou≈æ√≠vaj√≠ p≈ôesnƒõ <b>dt</b>. solve_ivp metody jsou adaptivn√≠, ale v√Ωsledky jsou vzorkovan√© na t_eval.
      </div>
    </div>

    </div>

    <p class="hint">
      Tip: Klikni na blok pro editaci parametr≈Ø vlevo. Propoj porty ta≈æen√≠m z v√Ωstupu do vstupu. Dvojklik na dr√°t p≈ôid√° zlom (vertex), kter√Ω lze t√°hnout. Nav√≠c: m≈Ø≈æe≈° chytnout dr√°t kdekoliv a tahem vytvo≈ôit/posunout zlom.
      <br><br>
      MVP pravidla: 1 dr√°t na 1 vstup. ≈Ω√°dn√© ƒçistƒõ algebraick√© cykly.
    </p>
  </div>

  <!-- Canvas -->
  <div id="paperWrap" tabindex="0">
  <div id="schemeTabs"></div>
  <div id="paperMount"></div>
</div>
</div>

<!-- Floating Output Panel (toggle with button/F2) -->
<div id="outputWindow" class="floating-panel" aria-hidden="true">
  <div class="fp-header" id="outputHeader">
    <span>Output</span>
    <div class="fp-actions">
      <button class="fp-btn" onclick="toggleOutput(false)">Close</button>
    </div>
  </div>
  <div class="fp-body">
    <div id="jsStatus" class="hint">JS not started yet.</div>
    <div id="plot" style="height:240px;"></div>
    <div id="out" class="hint">‚Äî</div>
    <h4>Last exported JSON</h4>
    <pre id="jsonOut">{}</pre>
  </div>
</div>

<!-- Floating Plot Window (opened by double-click on Plot block) -->
<div id="plotWindow" class="floating-panel" aria-hidden="true">
  <div class="fp-header" id="plotHeader">
    <span id="plotTitle">Plot</span>
    <div class="fp-actions">
      <button class="fp-btn" onclick="togglePlotWindow(false)">Close</button>
    </div>
  </div>
  <div class="fp-body">
    <div id="plotCanvas"></div>
    <div id="plotMeta" class="hint" style="margin-top:8px;"></div>
  </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  const jsStatusEl = document.getElementById('jsStatus');
  const setStatus = (t) => { if (jsStatusEl) jsStatusEl.textContent = t; };

  // ===== Floating window helpers =====
  function toggleOutput(force) {
    const w = document.getElementById('outputWindow');
    const btn = document.getElementById('toggleOutputBtn');
    if (!w) return;
    const show = (typeof force === 'boolean') ? force : !w.classList.contains('show');
    w.classList.toggle('show', show);
    w.setAttribute('aria-hidden', show ? 'false' : 'true');
    if (btn) btn.textContent = show ? 'Hide Output (F2)' : 'Show Output (F2)';
  }

  function togglePlotWindow(force) {
    const w = document.getElementById('plotWindow');
    if (!w) return;
    const show = (typeof force === 'boolean') ? force : !w.classList.contains('show');
    w.classList.toggle('show', show);
    w.setAttribute('aria-hidden', show ? 'false' : 'true');
    if (!show && typeof Plotly !== 'undefined') { try { Plotly.purge('plotCanvas'); } catch(e){} }
  }

  window.toggleOutput = toggleOutput;
  window.togglePlotWindow = togglePlotWindow;

  function makeDraggable(winEl, headerEl) {
    let dragging = false, startX = 0, startY = 0, origX = 0, origY = 0;

    const onDown = (e) => {
      if (e.target && e.target.closest && e.target.closest('button')) return;
      dragging = true;
      const r = winEl.getBoundingClientRect();
      origX = r.left; origY = r.top;
      startX = e.clientX; startY = e.clientY;
      winEl.style.left = origX + 'px';
      winEl.style.top = origY + 'px';
      winEl.style.right = 'auto';
      e.preventDefault();
    };

    const onMove = (e) => {
      if (!dragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      winEl.style.left = (origX + dx) + 'px';
      winEl.style.top  = (origY + dy) + 'px';
    };

    const onUp = () => { dragging = false; };

    headerEl.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }

  // F2 toggles Output window
  document.addEventListener('keydown', (e) => {
    if (e.key === 'F2') {
      e.preventDefault();
      toggleOutput();
    }
  });

  setTimeout(() => {
    const ow = document.getElementById('outputWindow');
    const oh = document.getElementById('outputHeader');
    const pw = document.getElementById('plotWindow');
    const ph = document.getElementById('plotHeader');
    if (ow && oh) makeDraggable(ow, oh);
    if (pw && ph) makeDraggable(pw, ph);
    toggleOutput(false);
    togglePlotWindow(false);
  }, 0);

  // Store last simulation response for Plot double-click
  let __lastSim = null;
  let __lastSimSig = null; // signature of graph used for __lastSim


  window.onerror = function(msg, url, line, col, err) {
    setStatus('JS ERROR: ' + msg + ' (line ' + line + ')');
  };

  if (typeof joint === 'undefined' || !joint.dia) {
    setStatus('JointJS is NOT defined. Check CDN availability.');
    return;
  }

  setStatus('JS started. Initializing JointJS editor...');


  // ===== Left panel tabs (Blocks / Run / Settings) =====
  function __setLeftTab(name){
    document.querySelectorAll('.ltab').forEach(b => b.classList.toggle('active', b.dataset.tab === name));
    document.querySelectorAll('.lsection').forEach(s => s.classList.remove('show'));
    const el = document.getElementById('tab_' + name);
    if (el) el.classList.add('show');
  }
  document.querySelectorAll('.ltab').forEach(b => {
    b.addEventListener('click', () => __setLeftTab(b.dataset.tab || 'blocks'));
  });


  // ---- Block library: ports + default params ----
  const BLOCK_LIBRARY = {
  Constant:   { inputs: [], outputs: ['y'], defaultParams: { value: 1.0 }, desc: 'constant source' },
  Gain:       { inputs: ['u'], outputs: ['y'], defaultParams: { k: 1.0 }, desc: 'multiply input' },

  // Multi-input sum: inputs u1..uN where N=params.n; signs string (e.g. '++-+')
  Sum:        { inputs: ['u1','u2'], outputs: ['y'], defaultParams: { n: 2, signs: '++' }, desc: 'sum inputs' },

  Integrator: { inputs: ['u'], outputs: ['y'], defaultParams: { x0: 0.0 }, desc: '‚à´ u dt' },
  Saturation: { inputs: ['u'], outputs: ['y'], defaultParams: { lower: -1.0, upper: 1.0 }, desc: 'limit signal to [lower, upper]' },

  // Multi-input scope: inputs u1..uN where N=params.n
  Plot:       { inputs: ['u'], outputs: [], defaultParams: { n: 1, label: '' }, desc: 'signal scope' },

  // Display sink: shows last simulated value of its input
  Display:    { inputs: ['u'], outputs: [], defaultParams: { label: '', fmt: '%.4g', value: '' }, desc: 'show value' },

  TransferFunction: { inputs: ['u'], outputs: ['y'], defaultParams: { num: '1', den: '1,1' }, desc: 'continuous LTI system' },
};


  // ---- Short display names (canvas titles) ----
  const SHORT_NAMES = {
  Constant: 'Const',
  TransferFunction: 'TF',
  Integrator: 'Int',
  Gain: 'Gain',
  Sum: 'Sum',
  Saturation: 'Sat',
  Plot: 'Plot',
  Display: 'Disp'
};
  function shortTypeName(type) { return SHORT_NAMES[type] || type; }

  // ===== JointJS graph + paper =====
  const namespace = joint.shapes;
  const graph = new joint.dia.Graph({}, { cellNamespace: namespace });

  // ===== Undo/Redo (CTRL+Z / CTRL+Y, multiple steps) =====
  const __UNDO_MAX = 80;
  let __undoStack = [];
  let __redoStack = [];
  let __histLock = false;      // prevents recording during restore
  let __histTimer = null;

  function __pushUndoSnapshot() {
    if (__histLock) return;
    try {
      const snap = graph.toJSON();
      const last = __undoStack.length ? __undoStack[__undoStack.length - 1] : null;
      const s1 = JSON.stringify(snap);
      const s0 = last ? JSON.stringify(last) : null;
      if (s0 === s1) return; // avoid duplicates
      __undoStack.push(snap);
      if (__undoStack.length > __UNDO_MAX) __undoStack.shift();
      // any new change invalidates redo stack
      __redoStack = [];
    } catch (e) {
      // ignore
    }
  }

  function __scheduleSnapshot() {
    if (__histLock) return;
    if (__histTimer) clearTimeout(__histTimer);
    __histTimer = setTimeout(() => {
      __histTimer = null;
      __pushUndoSnapshot();
    }, 220);
  }

  function __restoreSnapshot(snap) {
    if (!snap) return;
    __histLock = true;
    try {
      // Restore full graph (cells + links)
      graph.fromJSON(snap);

      // Clear selection states (views will be recreated)
      try {
        selectedNodeId = null;
        selectedNodeIds = new Set();
        clearBlockSelection();
        renderParamEditor();
      } catch(e) {}

      try { setSelectedLink(null); } catch(e) {}
      try { refreshAllPlotNodeLabels(); } catch(e) {}
    } finally {
      __histLock = false;
    }
  }

  function undo() {
    if (__histLock) return;
    if (__undoStack.length <= 1) return; // keep at least one (current) snapshot
    const current = __undoStack.pop();
    __redoStack.push(current);
    const prev = __undoStack[__undoStack.length - 1];
    __restoreSnapshot(prev);
  }

  function redo() {
    if (__histLock) return;
    if (!__redoStack.length) return;
    const next = __redoStack.pop();
    __undoStack.push(next);
    __restoreSnapshot(next);
  }

  // Record history on *any* graph structural or attribute change (debounced)
  graph.on('add remove change', (cell, opt = {}) => {
    if (opt && opt.skipHistory) return;
    __scheduleSnapshot();
  });

  // Keyboard bindings
  document.addEventListener('keydown', (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
    const isTyping = (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (e.target && e.target.isContentEditable));
    if (isTyping) return;

    const key = (e.key || '').toLowerCase();

    // Ctrl+Z => Undo, Ctrl+Shift+Z or Ctrl+Y => Redo
    if (e.ctrlKey && !e.altKey && key === 'z') {
      e.preventDefault();
      if (e.shiftKey) redo();
      else undo();
    } else if (e.ctrlKey && !e.altKey && key === 'y') {
      e.preventDefault();
      redo();
    }
  }, true);

  // Initialize with an initial snapshot (empty graph; will be updated after default model is added)
  __pushUndoSnapshot();



  

    // ===== Delete key: remove selected link(s) and/or selected block(s) (and connected links) =====
  document.addEventListener('keydown', (e) => {
    if (e.key !== 'Delete' && e.key !== 'Backspace') return;

    // Don't hijack Delete/Backspace while typing in inputs/textareas or editable elements.
    const ae = document.activeElement;
    if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) return;

    const linkIds = (typeof selectedLinkIds !== 'undefined' && selectedLinkIds && selectedLinkIds.size)
      ? Array.from(selectedLinkIds).map(String)
      : (typeof selectedLinkId !== 'undefined' && selectedLinkId ? [String(selectedLinkId)] : []);

    const blockIds = (typeof selectedNodeIds !== 'undefined' && selectedNodeIds && selectedNodeIds.size)
      ? Array.from(selectedNodeIds).map(String)
      : (typeof selectedNodeId !== 'undefined' && selectedNodeId ? [String(selectedNodeId)] : []);

    if (!linkIds.length && !blockIds.length) return;

    // Remove selected links first
    linkIds.forEach(id => {
      const l = graph.getCell(String(id));
      if (l && l.isLink()) l.remove();
    });

    // Remove selected blocks (and any links connected to them)
    blockIds.forEach(id => {
      const el = graph.getCell(String(id));
      if (!el || (el.isLink && el.isLink())) return;
      const links = graph.getConnectedLinks(el);
      links.forEach(link => link.remove());
      el.remove();
    });

    // Clear selection state
    try {
      selectedNodeId = null;
      selectedNodeIds = new Set();
      clearBlockSelection();
      renderParamEditor();
    } catch(e) {}

    try { clearSelectedLinks(); } catch(e) {}
    try { refreshAllPlotNodeLabels(); } catch(e) {}
    try { clearHover(); } catch(e) {}

    e.preventDefault();
    e.stopPropagation();
  }, true);
const wrap = document.getElementById('paperWrap');
  const paperMount = document.getElementById('paperMount');
  
  // ===== Connection validation (Simulink-style) =====
  function __getPortGroup(m) {
    if (!m) return null;
    return m.getAttribute('port-group') ||
           (m.closest && (m.closest('[port-group]') && m.closest('[port-group]').getAttribute('port-group'))) ||
           (m.closest && (m.closest('.joint-port') && m.closest('.joint-port').getAttribute('port-group'))) ||
           null;
  }
const paper = new joint.dia.Paper({
    // Only allow starting a wire from OUT ports (ports have port-group="out")
    validateMagnet: function(cellView, magnet) {
      return __getPortGroup(magnet) === 'out' || __getPortGroup(magnet) === 'in';
    },

    // Enforce OUT ‚Üí IN and forbid connecting to blocks without any IN ports.
    validateConnection: function(srcView, srcMagnet, tgtView, tgtMagnet) {
      // If no target magnet, connection is invalid (dropping on element body / blank)
      if (!tgtMagnet || !tgtView || !tgtView.model) return false;

      // Must be from OUT port
      if (__getPortGroup(srcMagnet) !== 'out') return false;

      // Must be to IN port
      if (__getPortGroup(tgtMagnet) !== 'in') return false;

      // Target element must have at least one input port group 'in'
      const ports = (tgtView.model.getPorts) ? tgtView.model.getPorts() : [];
      const hasInput = ports.some(p => p.group === 'in');
      if (!hasInput) return false;

      return true;
    },

    el: paperMount,
    model: graph,
    gridSize: 20,
    drawGrid: true,
    async: true,
    background: { color: 'transparent' },
    cellViewNamespace: namespace,
    defaultLink: () => {
      const l = new joint.shapes.standard.Link();
      l.attr({
        line: {
          stroke: '#4a90e2',
          strokeWidth: 2.2,
          targetMarker: { type: 'path', d: 'M 10 -5 0 0 10 5 z' }
        }
      });

  // ===== Diagram zoom (paper scale) with CTRL + mouse wheel =====
  // Zooms the JointJS paper only (not the whole page). Keeps the point under cursor stable.
  let __paperScale = { x: 1, y: 1 };
  const __ZOOM_MIN = 0.35;
  const __ZOOM_MAX = 2.5;
  const __ZOOM_STEP = 1.12; // per wheel notch

  function __clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function __setPaperScaleAroundClientPoint(newS, clientPt) {
    // Keep cursor position stable: adjust translate based on local point before/after scaling.
    const before = paper.clientToLocalPoint(clientPt);

    paper.scale(newS, newS);
    __paperScale = { x: newS, y: newS };

    const after = paper.clientToLocalPoint(clientPt);

    const dx = (after.x - before.x) * newS;
    const dy = (after.y - before.y) * newS;

    const t = paper.translate();
    paper.translate((t.tx || 0) + dx, (t.ty || 0) + dy);
  }

  wrap.addEventListener('wheel', (e) => {
    if (!e.ctrlKey) return;              // only CTRL + wheel
    e.preventDefault();                  // prevent browser zoom
    e.stopPropagation();

    const dir = (e.deltaY < 0) ? 1 : -1; // wheel up => zoom in
    const factor = (dir > 0) ? __ZOOM_STEP : (1 / __ZOOM_STEP);
    const next = __clamp(__paperScale.x * factor, __ZOOM_MIN, __ZOOM_MAX);

    __setPaperScaleAroundClientPoint(next, { x: e.clientX, y: e.clientY });
  }, { passive: false });


      

  // ===== UX: Pan the whole diagram with RIGHT mouse button (DOM-based, reliable) =====
  // Right-drag on empty canvas pans the paper. Left button stays for selection/move.
  let __panning = false;
  let __panStartClient = { x: 0, y: 0 };
  let __panStartTranslate = { x: 0, y: 0 };

  // Disable browser context menu on canvas so RMB drag works everywhere
  wrap.addEventListener('contextmenu', (e) => e.preventDefault());

  function __isInteractiveTarget(t) {
    // If user right-clicks a block/link/port, don't pan (avoid conflicts)
    return !!(t && (t.closest('.joint-element') || t.closest('.joint-link') || t.closest('.joint-port')));
  }

  wrap.addEventListener('mousedown', (e) => {
    if (e.button !== 2) return;                // 2 = right mouse button
    if (__isInteractiveTarget(e.target)) return;

    __panning = true;
    __panStartClient = { x: e.clientX, y: e.clientY };
    const tr = paper.translate();
    __panStartTranslate = { x: tr.tx || 0, y: tr.ty || 0 };

    e.preventDefault();
    e.stopPropagation();
  }, true);

  window.addEventListener('mousemove', (e) => {
    if (!__panning) return;
    const dx = e.clientX - __panStartClient.x;
    const dy = e.clientY - __panStartClient.y;
    paper.translate(__panStartTranslate.x + dx, __panStartTranslate.y + dy);
    e.preventDefault();
  }, true);

  window.addEventListener('mouseup', (e) => {
    if (e.button !== 2) return;
    __panning = false;
  }, true);

  
  // ===== LMB drag: box selection of multiple blocks (marquee) =====
  // Drag on empty canvas (left button) draws a rectangle and selects intersecting blocks.
  let __boxSel = null; // { startClient:{x,y}, rectEl }
  function __clientRectToLocalRect(c0, c1) {
    const p0 = paper.clientToLocalPoint(c0);
    const p1 = paper.clientToLocalPoint(c1);
    const x1 = Math.min(p0.x, p1.x), y1 = Math.min(p0.y, p1.y);
    const x2 = Math.max(p0.x, p1.x), y2 = Math.max(p0.y, p1.y);
    return { x: x1, y: y1, width: (x2 - x1), height: (y2 - y1) };
  }
  function __rectsIntersect(a, b) {
    return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
  }
  function __rectContains(outer, inner) {
    return (inner.x >= outer.x && inner.y >= outer.y &&
            (inner.x + inner.width) <= (outer.x + outer.width) &&
            (inner.y + inner.height) <= (outer.y + outer.height));
  }
  function __isBlankTarget(t) {
    // Only start box selection when clicking on empty background, not on elements/links/ports.
    return !(t && (t.closest('.joint-element') || t.closest('.joint-link') || t.closest('.joint-port')));
  }

  wrap.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return; // left only
    if (!__isBlankTarget(e.target)) return;

    __boxSel = { startClient: { x: e.clientX, y: e.clientY }, rectEl: null };

    const r = document.createElement('div');
    r.className = 'box-select-rect';
    r.style.left = '0px';
    r.style.top = '0px';
    r.style.width = '0px';
    r.style.height = '0px';
    wrap.appendChild(r);
    __boxSel.rectEl = r;

    // Clear selection at start of box select unless Ctrl is held (Ctrl = additive selection)
    if (!e.ctrlKey) {
      selectedNodeId = null;
      selectedNodeIds = new Set();
      clearBlockSelection();
      try { clearSelectedLinks(); } catch(e) {}
      renderParamEditor();
    }

    e.preventDefault();
  }, true);

  window.addEventListener('mousemove', (e) => {
    if (!__boxSel) return;
    const x0 = __boxSel.startClient.x, y0 = __boxSel.startClient.y;
    const x1 = e.clientX, y1 = e.clientY;

    const left = Math.min(x0, x1), top = Math.min(y0, y1);
    const w = Math.abs(x1 - x0), h = Math.abs(y1 - y0);

    if (__boxSel.rectEl) {
      const wrapRect = wrap.getBoundingClientRect();
      __boxSel.rectEl.style.left = (left - wrapRect.left) + 'px';
      __boxSel.rectEl.style.top = (top - wrapRect.top) + 'px';
      __boxSel.rectEl.style.width = w + 'px';
      __boxSel.rectEl.style.height = h + 'px';
    }
  }, true);

  window.addEventListener('mouseup', (e) => {
    if (!__boxSel) return;

    const c0 = __boxSel.startClient;
    const c1 = { x: e.clientX, y: e.clientY };
    const selLocal = __clientRectToLocalRect(c0, c1);

    const hitBlocks = [];
    graph.getElements().forEach(el => {
      const bb = el.getBBox(); // paper local coords
      const r = { x: bb.x, y: bb.y, width: bb.width, height: bb.height };
      if (__rectsIntersect(selLocal, r)) hitBlocks.push(String(el.id));
    });

    // Links: only those whose *entire* geometry lies inside the selection rectangle.
    const hitLinks = [];
    graph.getLinks().forEach(link => {
      const bb = link.getBBox(); // bbox of the whole link path
      const r = { x: bb.x, y: bb.y, width: bb.width, height: bb.height };
      if (__rectContains(selLocal, r)) hitLinks.push(String(link.id));
    });

    const additive = !!(e && e.ctrlKey);

    // Update block selection (additive or replace)
    if (!additive) {
      selectedNodeIds = new Set(hitBlocks);
    } else {
      if (!selectedNodeIds) selectedNodeIds = new Set();
      hitBlocks.forEach(id => selectedNodeIds.add(String(id)));
    }
    const blockIds = Array.from(selectedNodeIds || []);
    selectedNodeId = (blockIds.length === 1) ? blockIds[0] : null;
    setSelectedBlocks(selectedNodeIds);

    // Update link selection (additive or replace)
    try { setSelectedLinks(hitLinks, { additive }); } catch(err) {}

    renderParamEditor();

    if (__boxSel.rectEl && __boxSel.rectEl.parentNode) __boxSel.rectEl.parentNode.removeChild(__boxSel.rectEl);
    __boxSel = null;
  }, true);


l.router('manhattan', { step: 20, padding: 12 });
      l.connector('rounded', { radius: 8 });
      return l;
    },
    interactive: function(cellView) {
      // We implement link vertex editing ourselves (Shift+drag). Disable Joint's built-in vertex handles
      // so vertices can't be moved/added/removed without Shift.
      if (cellView.model.isLink()) return { vertexAdd: false, vertexMove: false, vertexRemove: false, arrowheadMove: false, linkMove: false, labelMove: false };
      return true;
    },
    linkPinning: false,
    snapLinks: { radius: 30 },
    markAvailable: true
  });
  // === Port positioning: tangent to block edge (circle edge touches the block edge) ===
  // We keep the visual port radius = 7, but shift the port CENTER inward by 7px.
  const PORT_RADIUS = 7;     // must match portBody r
  const PORT_INSET  = PORT_RADIUS;

  function leftInsetPositioner(ports, elBBox /*, opt */) {
    const n = ports.length || 1;
    const pad = 14; // vertical padding inside the block
    const h = Math.max(1, elBBox.height - 2 * pad);
    return ports.map((p, i) => ({
      x: elBBox.x - PORT_INSET,
      y: elBBox.y + pad + (n === 1 ? h / 2 : (h * i) / (n - 1))
    }));
  }

  function rightInsetPositioner(ports, elBBox /*, opt */) {
    const n = ports.length || 1;
    const pad = 14;
    const h = Math.max(1, elBBox.height - 2 * pad);
    return ports.map((p, i) => ({
      x: elBBox.x + elBBox.width + PORT_INSET,
      y: elBBox.y + pad + (n === 1 ? h / 2 : (h * i) / (n - 1))
    }));
  }


  function fitPaper() {
    // Force paper to occupy the full remaining right side (window width minus left panel).
    const panel = document.querySelector('.panel');
    const leftW = panel ? panel.getBoundingClientRect().width : 260;
    const w = Math.max(200, window.innerWidth - leftW);
    const h = Math.max(200, window.innerHeight);
    // Ensure the wrapper itself is sized deterministically
    wrap.style.width = w + 'px';
    wrap.style.height = h + 'px';
    const tabsH = 36;
    if (paperMount) {
      paperMount.style.top = tabsH + 'px';
      paperMount.style.height = (h - tabsH) + 'px';
    }
    paper.setDimensions(w, Math.max(200, h - tabsH));
  }
  window.addEventListener('resize', fitPaper);
  setTimeout(() => fitPaper(), 0);
  requestAnimationFrame(() => fitPaper());
// ===== Ports config =====
  const PORT_MARKUP = [
    // Larger invisible hit area so the user can reliably start a connection
    { tagName: 'circle', selector: 'portHit', attributes: { r: 7, fill: 'none', stroke: 'transparent', 'stroke-width': 18, 'pointer-events': 'stroke', class: 'joint-port-hit' } },
    { tagName: 'circle', selector: 'portBody', attributes: { r: 7, class: 'joint-port-body' } },
    // Let clicks go through the text to the magnet circle(s)
    { tagName: 'text', selector: 'portArrow', attributes: { 'font-size': 11, 'font-weight': 900, 'text-anchor': 'middle', 'y': 4, 'pointer-events': 'none' } }
  ];

  const portGroups = {
    in: {
      position: leftInsetPositioner,

      attrs: {
        portHit: { magnet: 'passive' },
        portBody: { fill: '#f5a3c7', stroke: '#d86aa0', magnet: 'passive' },
        portArrow: { text: '‚ñ∂', fill: '#000', x: 0 }
      },
      markup: PORT_MARKUP,
      label: { position: { name: 'left', args: { y: 0 } }, markup: [] }
    },
    out: {
      position: rightInsetPositioner,

      attrs: {
        portHit: { magnet: true },
        portBody: { fill: '#9ecbff', stroke: '#4a90e2', magnet: true },
        portArrow: { text: '‚ñ∂', fill: '#000', x: 0 }
      },
      markup: PORT_MARKUP,
      label: { position: { name: 'right', args: { y: 0 } }, markup: [] }
    }
  };

  // ===== Node HTML (kept: title + desc + paramsLine) =====
  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#039;');
  }

  function formatParamsLine(type, params, meta) {
    const spec = BLOCK_LIBRARY[type] || {};
    const defaults = spec.defaultParams || {};

    if (type === 'Plot') {
  const sigs = (meta && Array.isArray(meta.signalPrettyList)) ? meta.signalPrettyList.map(String) : [];
  const sigLine = sigs.length ? sigs.join(' | ') : '';
  const lbl = (params && typeof params.label === 'string') ? params.label.trim() : '';
  if (lbl && sigLine && lbl !== sigLine) return `${lbl} ‚Äî ${sigLine}`;
  if (lbl) return lbl;
  if (sigLine) return sigLine;
  return '(not connected)';
}
if (type === 'Display') {
  const sig = (meta && meta.signalPretty) ? String(meta.signalPretty) : '';
  const lbl = (params && typeof params.label === 'string') ? params.label.trim() : '';
  const val = (params && params.value !== undefined) ? String(params.value) : '';
  const left = (lbl || sig) ? (lbl || sig) : '(not connected)';
  if (val) return `${left} = ${val}`;
  return left;
}
if (type === 'Constant')   return `value=${(params && params.value !== undefined) ? params.value : defaults.value}`;
    if (type === 'Gain')       return `k=${(params && params.k !== undefined) ? params.k : defaults.k}`;
    if (type === 'Sum')        return `signs=${(params && params.signs !== undefined) ? params.signs : defaults.signs}`;
    if (type === 'Integrator') return `x0=${(params && params.x0 !== undefined) ? params.x0 : defaults.x0}`;
    if (type === 'Saturation') {
      const lo = (params && params.lower !== undefined) ? params.lower : defaults.lower;
      const hi = (params && params.upper !== undefined) ? params.upper : defaults.upper;
      return `lower=${lo}, upper=${hi}`;
    }
    if (type === 'TransferFunction') {
      const num = (params && params.num !== undefined) ? params.num : defaults.num;
      const den = (params && params.den !== undefined) ? params.den : defaults.den;
      return `num=${num}, den=${den}`;
    }

    const parts = [];
    for (const k of Object.keys(defaults)) {
      const cur = (params && params[k] !== undefined) ? params[k] : defaults[k];
      parts.push(`${k}=${cur}`);
    }
    return parts.join(', ');
  }

  function computeInboundSignalPretty(el, targetPort) {
  if (!el) return '';
  const inbound = graph.getConnectedLinks(el, { inbound: true }) || [];
  const link = inbound.find(l => (l.get('target') || {}).port === targetPort);
  if (!link) return '';
  const src = link.get('source') || {};
  const srcId = String(src.id || '');
  const srcPort = String(src.port || 'y');
  const srcEl = graph.getCell(srcId);
  const srcType = srcEl ? srcEl.get('blockType') : '';
  if (!srcId) return '';
  return `${shortTypeName(srcType)} (${srcId}).${srcPort}`;
}

function computePlotSignalsPretty(plotId) {
  const plotEl = graph.getCell(String(plotId));
  if (!plotEl) return [];
  const p = plotEl.get('params') || {};
  const n = Math.max(1, parseInt(p.n ?? 1, 10) || 1);
  const out = [];
  for (let i = 1; i <= n; i++) {
    const port = (n === 1) ? 'u' : ('u' + i);
    const s = computeInboundSignalPretty(plotEl, port);
    out.push(s || '(not connected)');
  }
  return out;
}

function computeDisplaySignalPretty(displayId) {
  const el = graph.getCell(String(displayId));
  if (!el) return '';
  return computeInboundSignalPretty(el, 'u') || '';
}


  function blockText(type, id, params) {
    const shown = shortTypeName(type);
    const title = `${shown} (${id})`;
    const desc = (BLOCK_LIBRARY[type] && typeof BLOCK_LIBRARY[type].desc === 'string') ? BLOCK_LIBRARY[type].desc : '';

    let sigPretty = '';
let sigPrettyList = null;
if (type === 'Plot') sigPrettyList = computePlotSignalsPretty(id);
if (type === 'Display') sigPretty = computeDisplaySignalPretty(id) || '';
const line = formatParamsLine(type, params || {}, { signalPretty: sigPretty, signalPrettyList: sigPrettyList });

    // Using SVG <text> multiline (\n). JointJS splits lines.
    const parts = [title];
    if (desc) parts.push(desc);
    if (line) parts.push(line);
    return parts.join('\n');
  }

  // ===== Create blocks =====
  let nextId = 1;
  function allocId() { return String(nextId++); }

  

// ===== Keep block text upright (do not rotate label with the element) =====
function updateLabelUpright(el) {
  if (!el || el.isLink && el.isLink()) return;
  const a = (typeof el.angle === 'function') ? (el.angle() || 0) : 0;
  const sz = (typeof el.size === 'function') ? el.size() : { width: 0, height: 0 };
  // Label is centered inside the element by default; rotate around element center in local coords
  const cx = (sz.width || 0) / 2;
  const cy = (sz.height || 0) / 2;
  if (!a) {
    el.attr('label/transform', null);
  } else {
    el.attr('label/transform', `rotate(${-a}, ${cx}, ${cy})`);
  }
}

// ===== Auto-swap element size for 90¬∞/270¬∞ so the (upright) label stays inside =====
function ensureSizeMatchesAngle(el) {
  if (!el || (el.isLink && el.isLink())) return;
  if (el.get && el.get('__swappingSize')) return;

  const a = (typeof el.angle === 'function') ? (el.angle() || 0) : 0;
  const ang = (((a % 360) + 360) % 360);
  const base = (el.get && el.get('baseSize')) ? el.get('baseSize') : (typeof el.size === 'function' ? el.size() : { width: 0, height: 0 });

  const wantSwap = (ang === 90 || ang === 270);
  const target = wantSwap ? { width: base.height, height: base.width } : { width: base.width, height: base.height };

  const cur = (typeof el.size === 'function') ? el.size() : { width: 0, height: 0 };
  if (cur.width === target.width && cur.height === target.height) return;

  // Guard against resize->change:size loops
  if (el.set) el.set('__swappingSize', true, { silent: true });
  if (typeof el.resize === 'function') el.resize(target.width, target.height);
  if (el.unset) el.unset('__swappingSize', { silent: true });
}

// Track "baseSize" as the unrotated size (0¬∞/180¬∞). If resized while rotated,
// we still keep baseSize in unrotated orientation so swapping stays consistent.
function updateBaseSize(el) {
  if (!el || (el.isLink && el.isLink())) return;
  if (el.get && el.get('__swappingSize')) return;

  const a = (typeof el.angle === 'function') ? (el.angle() || 0) : 0;
  const ang = (((a % 360) + 360) % 360);
  const sz = (typeof el.size === 'function') ? el.size() : { width: 0, height: 0 };
  const base = (ang === 90 || ang === 270) ? { width: sz.height, height: sz.width } : { width: sz.width, height: sz.height };
  if (el.set) el.set('baseSize', base, { silent: true });
}

// Keep label upright & size consistent whenever the element rotates or resizes.
graph.on('change:angle', (cell) => {
  if (!cell || cell.isLink && cell.isLink()) return;
  ensureSizeMatchesAngle(cell);
  updateLabelUpright(cell);
});
graph.on('change:size', (cell) => {
  if (!cell || cell.isLink && cell.isLink()) return;
  updateBaseSize(cell);
  updateLabelUpright(cell);
});

// Keep label upright whenever the element rotates (or is resized).
graph.on('change:angle', (cell) => { if (cell && !cell.isLink()) updateLabelUpright(cell); });
graph.on('change:size',  (cell) => { if (cell && !cell.isLink()) updateLabelUpright(cell); });

  function createBlockCell(type, x, y, params, forcedId) {
    const spec = BLOCK_LIBRARY[type];
    if (!spec) throw new Error('Unknown type: ' + type);

    const id = forcedId ? String(forcedId) : allocId();
    const p0 = params ? JSON.parse(JSON.stringify(params)) : JSON.parse(JSON.stringify(spec.defaultParams));
    let p = p0;
    if (type === 'Sum') p = __normalizeSumParams(p0);
    if (type === 'Plot') p = __normalizePlotParams(p0);

    const el = new joint.shapes.standard.Rectangle({
      id,
      blockType: type,
      params: p
    });

    el.position(x, y);
    el.resize(170, 76);
    el.set('baseSize', { width: 170, height: 76 }, { silent: true });

    el.attr({
      body: {
        magnet: false,
        rx: 10, ry: 10,
        stroke: '#b8c0cc',
        strokeWidth: 1.2,
        fill: '#ffd1c8'
      },
      label: {
        magnet: false,
        text: blockText(type, id, p),
        fill: '#111',
        fontSize: 12,
        fontFamily: 'Arial, sans-serif',
        textWrap: { width: -10, height: -10 }
      }
    });

    // ports (some blocks have dynamic number of inputs)
function __portsFor(type, params) {
  if (type === 'Sum') {
    const n = Math.max(2, parseInt((params && params.n) ?? 2, 10) || 2);
    const ins = Array.from({ length: n }, (_, i) => 'u' + (i + 1));
    return { inputs: ins, outputs: ['y'] };
  }
  if (type === 'Plot') {
    const n = Math.max(1, parseInt((params && params.n) ?? 1, 10) || 1);
    const ins = (n === 1) ? ['u'] : Array.from({ length: n }, (_, i) => 'u' + (i + 1));
    return { inputs: ins, outputs: [] };
  }
  if (type === 'Display') {
    return { inputs: ['u'], outputs: [] };
  }
  const s = BLOCK_LIBRARY[type] || { inputs: [], outputs: [] };
  return { inputs: s.inputs || [], outputs: s.outputs || [] };
}

el.set('ports', { groups: portGroups, items: [] });
const dyn = __portsFor(type, p);
const inPorts  = (dyn.inputs || []).map(name => ({ id: name, group: 'in' }));
const outPorts = (dyn.outputs || []).map(name => ({ id: name, group: 'out' }));
el.addPorts([...inPorts, ...outPorts]);

    el.addTo(graph);
    updateLabelUpright(el);
    return el;
  }

function __normalizeSumParams(params) {
  const p = { ...(params || {}) };
  const n = Math.max(2, parseInt(p.n ?? 2, 10) || 2);
  p.n = n;
  let signs = String(p.signs ?? '').trim();
  if (!signs) signs = '+'.repeat(n);
  if (signs.length < n) signs = signs + '+'.repeat(n - signs.length);
  if (signs.length > n) signs = signs.slice(0, n);
  p.signs = signs;
  return p;
}

function __normalizePlotParams(params) {
  const p = { ...(params || {}) };
  const n = Math.max(1, parseInt(p.n ?? 1, 10) || 1);
  p.n = n;
  return p;
}

function __rebuildPortsForCell(el) {
  if (!el || (el.isLink && el.isLink())) return;
  const type = el.get('blockType');
  let p = el.get('params') || {};
  if (type === 'Sum') p = __normalizeSumParams(p);
  if (type === 'Plot') p = __normalizePlotParams(p);
  el.set('params', p, { silent: true });

  // Rebuild items
  el.set('ports', { groups: portGroups, items: [] });
  // Reuse the same port function used by createBlockCell:
  const dyn = (function __portsFor(type, params) {
    if (type === 'Sum') {
      const n = Math.max(2, parseInt((params && params.n) ?? 2, 10) || 2);
      const ins = Array.from({ length: n }, (_, i) => 'u' + (i + 1));
      return { inputs: ins, outputs: ['y'] };
    }
    if (type === 'Plot') {
      const n = Math.max(1, parseInt((params && params.n) ?? 1, 10) || 1);
      const ins = (n === 1) ? ['u'] : Array.from({ length: n }, (_, i) => 'u' + (i + 1));
      return { inputs: ins, outputs: [] };
    }
    if (type === 'Display') return { inputs: ['u'], outputs: [] };
    const s = BLOCK_LIBRARY[type] || { inputs: [], outputs: [] };
    return { inputs: s.inputs || [], outputs: s.outputs || [] };
  })(type, p);

  const inPorts  = (dyn.inputs || []).map(name => ({ id: name, group: 'in' }));
  const outPorts = (dyn.outputs || []).map(name => ({ id: name, group: 'out' }));
  el.addPorts([...inPorts, ...outPorts]);
}

function refreshAllDisplayNodeLabels() {
  graph.getElements().forEach(el => {
    if (el.get('blockType') === 'Display') refreshBlockText(String(el.id));
  });
}
function __formatValueWithFmt(x, fmt) {
  try {
    const f = String(fmt || '').trim();
    const v = (typeof x === 'number') ? x : parseFloat(x);
    if (!Number.isFinite(v)) return String(x);
    // very small printf-like: supports %.Nf and %.Ng (g as default)
    const m = f.match(/^%\.(\d+)([fg])$/i);
    if (m) {
      const n = parseInt(m[1], 10) || 4;
      const t = (m[2] || 'g').toLowerCase();
      if (t === 'f') return v.toFixed(n);
      return v.toPrecision(n);
    }
    return String(v);
  } catch(e) {
    return String(x);
  }
}

function updateDisplaysFromLastSim() {
  const data = __lastSim;
  if (!data || !data.logs) return;
  const ds = Array.isArray(window.displaySignals) ? window.displaySignals : [];
  ds.forEach(s => {
    const disp = graph.getCell(String(s.displayId));
    if (!disp) return;
    const key1 = `${s.block}.${s.port}`;
    const logs = data.logs || {};
    let series = logs[key1];
    if (!series) {
      // try to match "id(Type).port" style keys
      const candidates = Object.keys(logs).filter(k => String(k).endsWith(`.${s.port}`) && String(k).includes(String(s.block)));
      if (candidates.length) series = logs[candidates[0]];
    }
    if (!series || !series.length) return;
    const last = series[series.length - 1];
    const p = disp.get('params') || {};
    const fmt = p.fmt ?? '%.4g';
    const valStr = __formatValueWithFmt(last, fmt);
    disp.set('params', { ...p, value: valStr });
    refreshBlockText(String(disp.id));
  });
}


  function refreshBlockText(id) {
    const el = graph.getCell(String(id));
    if (!el || el.isLink()) return;
    const type = el.get('blockType');
    const params = el.get('params') || {};
    el.attr('label/text', blockText(type, String(id), params));
  }

  // ===== Selection + param editor =====
  let selectedNodeId = null;
  let selectedNodeIds = new Set();

  // --- Visual highlight for selected block (reliable via model attrs) ---
  const __SEL_STYLE = { stroke: '#8b5cf6', strokeWidth: 3, fill: '#f5f3ff' };

  function __applySelectionStyle(el, on) {
    if (!el || (el.isLink && el.isLink())) return;
    // Cache original style once
    const cached = el.get('__origBodyStyle');
    if (!cached) {
      const a = (el.attr('body') || {});
      el.set('__origBodyStyle', {
        stroke: a.stroke ?? '#b8c0cc',
        strokeWidth: a.strokeWidth ?? 1.2,
        fill: a.fill ?? '#ffd1c8'
      }, { silent: true });
    }
    const orig = el.get('__origBodyStyle') || { stroke:'#b8c0cc', strokeWidth:1.2, fill:'#ffd1c8' };
    el.attr('body/stroke', on ? __SEL_STYLE.stroke : orig.stroke);
    el.attr('body/strokeWidth', on ? __SEL_STYLE.strokeWidth : orig.strokeWidth);
    el.attr('body/fill', on ? __SEL_STYLE.fill : orig.fill);
  }

  function clearBlockSelection() {
    graph.getElements().forEach(el => __applySelectionStyle(el, false));
  }

  function setSelectedBlocks(ids) {
    clearBlockSelection();
    (ids || []).forEach(id => {
      const el = graph.getCell(String(id));
      if (el) __applySelectionStyle(el, true);
    });
  }


  function renderParamEditor() {
    const info = document.getElementById('selectedInfo');
    const pe = document.getElementById('paramEditor');
    pe.innerHTML = '';

    if (!selectedNodeId) {
      info.textContent = 'Nothing selected.';
      return;
    }
    // Multi-select: show summary and skip param editor
    if (selectedNodeIds && selectedNodeIds.size > 1) {
      const ids = Array.from(selectedNodeIds).map(String).sort((a,b)=>parseInt(a,10)-parseInt(b,10));
      info.innerHTML = `<div><b>${ids.length} blocks selected</b><br>` + ids.map(id => ('#' + id)).join(', ') + `</div>`;
      pe.innerHTML = `<div class="hint">V√≠cen√°sobn√Ω v√Ωbƒõr: editace parametr≈Ø je vypnut√°. Klikni na jeden blok pro editaci.</div>`;
      return;
    }


    const node = graph.getCell(String(selectedNodeId));
    if (!node) {
      selectedNodeId = null;
      info.textContent = 'Nothing selected.';
      return;
    }

    const type = node.get('blockType');
    const spec = BLOCK_LIBRARY[type];
    const params = node.get('params') || {};

    info.innerHTML = `<div><b>ID:</b> ${selectedNodeId} <br><b>Type:</b> ${escapeHtml(type)}</div>`;

    const defaults = (spec && spec.defaultParams) ? spec.defaultParams : {};
    const keys = Object.keys(defaults);

    if (!keys.length) {
      pe.innerHTML = `<div class="hint">No params for this block.</div>`;
      return;
    }

    keys.forEach((k) => {
      const row = document.createElement('div');
      row.className = 'kv';
      const lab = document.createElement('label');
      lab.textContent = k;

      const inp = document.createElement('input');
      const defv = defaults[k];
      const isNum = (typeof defv === 'number');
      inp.type = isNum ? 'number' : 'text';
      if (isNum) inp.step = 'any';
      inp.value = (params[k] !== undefined) ? params[k] : defv;

      const nodeId = String(selectedNodeId);

      const commit = () => {
        const n = graph.getCell(nodeId);
        if (!n) return;

        let newVal;
        if (isNum) {
          const v = parseFloat(inp.value);
          newVal = Number.isFinite(v) ? v : defv;
        } else {
          newVal = inp.value;
        }

        const newParams = { ...(n.get('params') || {}) , [k]: newVal };
        n.set('params', newParams);
// If this param changes port count / signage, rebuild ports
try {
  const t = n.get('blockType');
  if ((t === 'Sum' && (k === 'n' || k === 'signs')) || (t === 'Plot' && k === 'n')) {
    __rebuildPortsForCell(n);
  }
} catch(e) {}
refreshBlockText(nodeId);
      };

      inp.addEventListener('focus', () => { try { inp.select(); } catch(e){} });
      inp.addEventListener('input', commit);
      inp.addEventListener('change', commit);
      inp.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { commit(); inp.blur(); }
      });

      row.appendChild(lab);
      row.appendChild(inp);
      pe.appendChild(row);
    });
  }
  // ===== RMB drag copy (duplicate block) =====
  let __copyDrag = null;
  let __copyDragDown = false; // guard against duplicate RMB copy triggers
 // { id }
  function __isRmb(evt){
    if (!evt) return false;
    const oe = evt.originalEvent || evt;
    // Support MouseEvent, PointerEvent, and some library-wrapped events.
    const button = (typeof oe.button === 'number') ? oe.button : (typeof evt.button === 'number' ? evt.button : null);
    const which = (typeof oe.which === 'number') ? oe.which : (typeof evt.which === 'number' ? evt.which : null);
    const buttons = (typeof oe.buttons === 'number') ? oe.buttons : (typeof evt.buttons === 'number' ? evt.buttons : null);
    return (button === 2) || (which === 3) || (buttons !== null && (buttons & 2) === 2);
  }
  function __startCopyDrag(elementView, evt) {
    // RMB copy-drag with ghost preview.
    // We create the clone ONLY on RMB release (mouseup/pointerup),
    // but we show a lightweight ghost during the drag so the user sees what's happening.
    const src = elementView && elementView.model;
    if (!src) return;

    // Guard against multiple handler firings during the same RMB press.
    if (__copyDragDown) return;
    __copyDragDown = true;

    const type = src.get('blockType');
    const params = JSON.parse(JSON.stringify(src.get('params') || {}));
    const angle = (src.angle && src.angle()) ? (src.angle() || 0) : (src.get('angle') || 0);

    const p = src.position();
    __copyDrag = { type, params, angle, lastPt: { x: p.x + 20, y: p.y + 20 } };

    // Stop other interactions while copying
    try { __panning = false; __boxSel = null; __wireDrag = null; } catch(e) {}

    // --- Ghost preview (HTML overlay, not a JointJS element) ---
    const wrap = document.getElementById('paperWrap');
    const ghost = document.createElement('div');
    ghost.className = 'copy-ghost';
    // Match the source block's footprint (silhouette)
    try {
      const sz = src.size ? src.size() : (src.get && src.get('size'));
      if (sz && sz.width && sz.height) {
        ghost.style.width = sz.width + 'px';
        ghost.style.height = sz.height + 'px';
      }
    } catch(e) {}
    const lab = document.createElement('div');
    lab.className = 'label';
    lab.textContent = type || 'Block';
    ghost.appendChild(lab);
    wrap.appendChild(ghost);

    // helper to position ghost in wrap coords
    const placeGhost = (clientX, clientY) => {
      try {
        const rect = wrap.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        ghost.style.left = x + 'px';
        ghost.style.top = y + 'px';
      } catch(e) {}
    };

    // Init ghost position
    try {
      const oe = evt && (evt.originalEvent || evt);
      placeGhost(oe.clientX, oe.clientY);
    } catch(e) {}

    const move = (e) => {
      if (!__copyDrag) return;
      const oe = e && (e.originalEvent || e);
      // Update last local-paper point
      try {
        const pt = paper.clientToLocalPoint({ x: oe.clientX, y: oe.clientY });
        __copyDrag.lastPt = { x: pt.x, y: pt.y };
      } catch(_) {}
      // Update ghost in screen coords
      placeGhost(oe.clientX, oe.clientY);
    };

    const cleanup = () => {
      __copyDrag = null;
      __copyDragDown = false;
      try { ghost.remove(); } catch(e) {}

      window.removeEventListener('mousemove', move, true);
      window.removeEventListener('pointermove', move, true);
      window.removeEventListener('mouseup', up, true);
      window.removeEventListener('pointerup', up, true);
      window.removeEventListener('pointercancel', up, true);
      window.removeEventListener('contextmenu', cm, true);
      window.removeEventListener('blur', blur, true);
    };

    const up = (e) => {
      // Drop: create the clone at the last recorded position
      if (!__copyDrag) { cleanup(); return; }

      const drop = __copyDrag.lastPt || { x: p.x + 20, y: p.y + 20 };
      const clone = createBlockCell(__copyDrag.type, drop.x, drop.y, __copyDrag.params);

      // Center element around drop point
      try {
        const sz = clone.size();
        clone.position(drop.x - (sz.width / 2), drop.y - (sz.height / 2));
      } catch(e) {}

      // Copy rotation
      try { clone.rotate(getAngleSnap(__copyDrag.angle || 0), true); } catch(e) {}
      updateLabelUpright(clone);

      cleanup();
      try { refreshAllPlotNodeLabels(); } catch(e) {}
    };

    // Prevent the context menu during RMB copy.
    const cm = (e) => { try { e.preventDefault(); e.stopPropagation(); } catch(_) {} return false; };
    const blur = () => cleanup();

    // Listen to BOTH mouse and pointer events (some browsers behave oddly with RMB moves)
    window.addEventListener('mousemove', move, true);
    window.addEventListener('pointermove', move, true);
    window.addEventListener('mouseup', up, true);
    window.addEventListener('pointerup', up, true);
    window.addEventListener('pointercancel', up, true);
    window.addEventListener('contextmenu', cm, true);
    window.addEventListener('blur', blur, true);
  }

  // Some JointJS builds/browsers do not reliably emit `element:pointerdown` for RMB.
  // Add a DOM-level fallback on the paper element. This makes RMB-copy work everywhere.
  let __rmbFallbackBound = false;
  function __bindRmbFallback(){
    if (__rmbFallbackBound) return;
    __rmbFallbackBound = true;
    const el = paper && paper.el;
    if (!el) return;

    const handler = (e) => {
      if (!__isRmb(e)) return;
      // Find JointJS view from the event target
      const view = paper.findView(e.target);
      if (!view || !view.model) return;
      if (!view.model.isElement || !view.model.isElement()) return;

      try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
      __startCopyDrag(view, e);
    };

    // Pointer events first, mouse as fallback.
    el.addEventListener('pointerdown', handler, true);
    el.addEventListener('mousedown', handler, true);
  }
  // Bind once now (paper already exists at this point in the script)
  try { __bindRmbFallback(); } catch(e) {}

  // Click-to-select (single click selects exactly one block)
  paper.on('element:pointerdown', (elementView, evt) => {
    // RMB + drag => copy block (Simulink-like)
    if (__isRmb(evt)) {
      try { evt.preventDefault(); evt.stopPropagation(); } catch(e) {}
      __startCopyDrag(elementView, evt);
      return;
    }

    if (evt && evt.stopPropagation) evt.stopPropagation();
    try { __wireDrag = null; clearHover(); } catch(e) {}

    const additive = !!(evt && evt.ctrlKey);
    const id = String(elementView.model.id);

    if (!additive) {
      // Normal click selects exactly one block and clears link selection.
      try { clearSelectedLinks(); } catch(e) {}
      selectedNodeId = id;
      selectedNodeIds = new Set([id]);
      setSelectedBlocks(selectedNodeIds);
      renderParamEditor();
      return;
    }

    // Ctrl+click toggles block in multi-selection (does not touch link selection).
    if (!selectedNodeIds) selectedNodeIds = new Set();
    if (selectedNodeIds.has(id)) selectedNodeIds.delete(id);
    else selectedNodeIds.add(id);

    const ids = Array.from(selectedNodeIds);
    selectedNodeId = (ids.length === 1) ? ids[0] : null;
    setSelectedBlocks(selectedNodeIds);
    renderParamEditor();
  });

  // Left click on blank clears selection (box-select uses DOM handlers below)
  paper.on('blank:pointerdown', (evt) => {
    if (evt && evt.button === 2) return; // RMB reserved for panning
    if (evt && evt.ctrlKey) return;     // Ctrl+drag may start additive box selection
    try { __wireDrag = null; clearSelectedLinks(); clearHover(); } catch(e) {}
    selectedNodeId = null;
    selectedNodeIds = new Set();
    clearBlockSelection();
    renderParamEditor();
  });

  // Ctrl+R rotates the currently selected block (snap 0/90/180/270)
  function getAngleSnap(a) {
    const n = Math.round(((a % 360) + 360) % 360 / 90) * 90;
    return (n + 360) % 360;
  }
  document.addEventListener('keydown', (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
    const isTyping = (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (e.target && e.target.isContentEditable));
    if (!isTyping && e.ctrlKey && (e.key === 'r' || e.key === 'R')) {
      e.preventDefault();
      if (!selectedNodeId) return;
      const el = graph.getCell(String(selectedNodeId));
      if (!el) return;
      const cur = el.angle() || 0;
      el.rotate(getAngleSnap(cur + 90), true);
      updateLabelUpright(el);
      // link reroute
      graph.getConnectedLinks(el).forEach(l => l.router('manhattan', { step: 20, padding: 12 }));
    }
  });

  // ===== Link behavior: enforce 1 wire per input =====
  function enforceOneWirePerInput(link) {
    const tgt = link.get('target') || {};
    if (!tgt.id || !tgt.port) return;
    const targetEl = graph.getCell(String(tgt.id));
    if (!targetEl) return;
    if (targetEl.get('blockType') === 'Plot') {
      // Plot input also should be single
    }
    const inbound = graph.getConnectedLinks(targetEl, { inbound: true });
    const samePort = inbound.filter(l => l.id !== link.id && (l.get('target') || {}).port === tgt.port);
    samePort.forEach(l => l.remove());
  }

  // Refresh Plot auto-labels after topology changes
  function refreshAllPlotNodeLabels() {
    graph.getElements().forEach(el => {
      if (el.get('blockType') === 'Plot') {
        // Auto-fill label if empty
        const p = el.get('params') || {};
        const curLabel = (typeof p.label === 'string') ? p.label.trim() : '';
        const sigs = computePlotSignalsPretty(el.id) || [];
        const sig = (sigs && sigs.length) ? sigs.join(' | ') : '';
        if (!curLabel && sig) {
          el.set('params', { ...p, label: sig });
        }
        refreshBlockText(el.id);
      }
    });
  }

  paper.on('link:connect', (linkView, evt, elementViewConnected, magnet, arrowhead) => {
    const link = linkView.model;
    if (arrowhead === 'target') {
      enforceOneWirePerInput(link);
      refreshAllPlotNodeLabels();
      try { updateDisplaysFromLastSim(); } catch(e) {}
      try { refreshAllDisplayNodeLabels(); } catch(e) {}
    }
  });
  paper.on('link:disconnect', () => refreshAllPlotNodeLabels());

  // ===== Hover highlight (ports OR links) + click selection for links =====
  let selectedLinkId = null;
  let selectedLinkIds = new Set(); // multi-select links


  // ===== Variant B: Drag wire segment anywhere (auto-creates/moves a vertex) =====
  // How it works:
  // - Mousedown on a link path creates a vertex at the cursor (or picks a nearby one)
  // - Mousemove updates that vertex position
  // - Mouseup ends the drag
  let __wireDrag = null; // { linkId, vIndex }
  const __WIRE_VERTEX_PICK_PX = 14;

  function __findNearestVertexIndex(link, pLocal) {
    const vs = link.vertices() || [];
    if (!vs.length) return -1;
    let best = -1;
    let bestD2 = Infinity;
    for (let i = 0; i < vs.length; i++) {
      const dx = vs[i].x - pLocal.x;
      const dy = vs[i].y - pLocal.y;
      const d2 = dx*dx + dy*dy;
      if (d2 < bestD2) { bestD2 = d2; best = i; }
    }
    return (Math.sqrt(bestD2) <= __WIRE_VERTEX_PICK_PX) ? best : -1;
  }

  paper.on('link:pointerdown', (linkView, evt) => {
    // Vertex-drag mode is ONLY when holding Shift.
    // Normal click selects the link (handled in the selection handler below).
    if (!evt || !evt.shiftKey) { __wireDrag = null; return; }

    // Only start "segment drag" when clicking on the visible link path, not on tools/handles.
    const isPath = evt && evt.target && (evt.target.tagName === 'path' || (evt.target.closest && evt.target.closest('path')));
    if (!isPath) return;

    const link = linkView.model;
    const p = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });

    let idx = __findNearestVertexIndex(link, p);
    if (idx < 0) {
      // Create new vertex at cursor position
      const vs = link.vertices() || [];
      vs.push({ x: p.x, y: p.y });
      link.vertices(vs);
      idx = vs.length - 1;
    }

    __wireDrag = { linkId: String(link.id), vIndex: idx };
    evt.preventDefault();
    evt.stopPropagation();
  });

  function __cancelWireDrag() { __wireDrag = null; }

  // Robust cancel paths (Joint events can be flaky depending on where the pointer ends up)
  paper.on('blank:pointerup', __cancelWireDrag);
  paper.on('link:pointerup', __cancelWireDrag);
  window.addEventListener('mouseup', __cancelWireDrag, true);
  window.addEventListener('keyup', (e) => { if (e.key === 'Shift') __cancelWireDrag(); }, true);

  // Move vertex while dragging (must keep holding Shift)
  window.addEventListener('mousemove', (e) => {
    if (!__wireDrag) return;
    if (!e.shiftKey) { __cancelWireDrag(); return; }

    const link = graph.getCell(__wireDrag.linkId);
    if (!link) { __cancelWireDrag(); return; }

    const p = paper.clientToLocalPoint({ x: e.clientX, y: e.clientY });
    const vs = link.vertices() || [];
    if (__wireDrag.vIndex >= 0 && __wireDrag.vIndex < vs.length) {
      vs[__wireDrag.vIndex] = { x: p.x, y: p.y };
      link.vertices(vs);
    }
    e.preventDefault();
  }, true);

  const hoverLinks = new Set();

  function clearHover() {
    for (const id of hoverLinks) {
      const l = graph.getCell(id);
      if (l && l.isLink() && !selectedLinkIds.has(String(id))) {
        l.attr('line/strokeWidth', 2.2);
        l.attr('line/filter', null);
      }
    }
    hoverLinks.clear();
  }

  function highlightLinks(links) {
    clearHover();
    links.forEach(l => {
      if (!l) return;
      if (selectedLinkIds.has(String(l.id))) return;
      l.attr('line/strokeWidth', 3.6);
      hoverLinks.add(String(l.id));
    });
  }

  
  function __resetLinkStyleById(id) {
    const l = graph.getCell(String(id));
    if (l && l.isLink()) {
      l.attr('line/stroke', '#4a90e2');
      l.attr('line/strokeWidth', 2.2);
    }
  }

  function __applyLinkSelectedStyleById(id) {
    const l = graph.getCell(String(id));
    if (l && l.isLink()) {
      l.attr('line/stroke', '#8b5cf6');
      l.attr('line/strokeWidth', 3.8);
    }
  }

  function clearSelectedLinks() {
    selectedLinkIds.forEach(id => __resetLinkStyleById(id));
    selectedLinkIds.clear();
    selectedLinkId = null;
  }

  function setSelectedLinks(ids, opts = {}) {
    // opts.additive: if true, add to existing selection; otherwise replace
    const additive = !!opts.additive;

    if (!additive) clearSelectedLinks();

    (ids || []).forEach(id => {
      const sid = String(id);
      if (!selectedLinkIds.has(sid)) {
        selectedLinkIds.add(sid);
        __applyLinkSelectedStyleById(sid);
      }
    });

    // Keep a single "active" id for legacy code paths
    selectedLinkId = selectedLinkIds.size ? Array.from(selectedLinkIds)[0] : null;
  }

  function toggleSelectedLink(id) {
    const sid = String(id);
    if (selectedLinkIds.has(sid)) {
      selectedLinkIds.delete(sid);
      __resetLinkStyleById(sid);
    } else {
      selectedLinkIds.add(sid);
      __applyLinkSelectedStyleById(sid);
    }
    selectedLinkId = selectedLinkIds.size ? Array.from(selectedLinkIds)[0] : null;
  }

  // Backward-compatible API: set one selected link (replaces selection)
  function setSelectedLink(link) {
    if (!link) { clearSelectedLinks(); return; }
    setSelectedLinks([String(link.id)], { additive: false });
  }


  paper.on('link:pointerdown', (linkView, evt) => {
    // If we're in Shift vertex-drag mode, don't treat this as selection.
    if (evt && evt.shiftKey) return;

    // Prevent Joint's default link interactions (e.g., moving vertices/segments) on normal click/drag.
    try { evt.preventDefault(); evt.stopPropagation(); } catch(e) {}
    // Any normal click cancels a potentially stuck drag state.
    __wireDrag = null;

    const additive = !!(evt && evt.ctrlKey);

    // If not additive, selecting a link clears block selection (classic behavior).
    if (!additive) {
      try {
        selectedNodeId = null;
        selectedNodeIds = new Set();
        clearBlockSelection();
        renderParamEditor();
      } catch (e) {}
    }

    // Ctrl+click toggles link in multi-selection; normal click selects exactly one link.
    if (additive) toggleSelectedLink(linkView.model.id);
    else setSelectedLink(linkView.model);
  });

  // Hover link
  paper.on('link:mouseenter', (linkView) => highlightLinks([linkView.model]));
  paper.on('link:mouseleave', () => clearHover());

  // Hover port (mouseenter on element -> inspect DOM target)
  paper.on('element:mouseenter', (elementView, evt) => {
    const portId = evt && evt.target ? evt.target.getAttribute('port') : null;
    if (!portId) return;
    const el = elementView.model;
    const isOut = (evt.target && evt.target.closest) ? !!evt.target.closest('.joint-port') && (evt.target.getAttribute('port-group') === 'out') : false;

    const links = graph.getConnectedLinks(el, isOut ? { outbound: true } : { inbound: true });
    const filtered = links.filter(l => {
      const s = l.get('source') || {}; const t = l.get('target') || {};
      return isOut ? (s.port === portId) : (t.port === portId);
    });
    if (filtered.length) highlightLinks(filtered);
  });
  paper.on('element:mouseleave', () => clearHover());

  // Delete key handling is implemented above (supports multi-select links + blocks).

  // ===== Public API: addBlock/save/load/exportGraph/simulate =====
  window.addBlock = function addBlock(type) {
    const spec = BLOCK_LIBRARY[type];
    if (!spec) return alert('Unknown type: ' + type);
    const x = 320 + Math.random() * 220;
    const y = 60 + Math.random() * 240;
    const el = createBlockCell(type, x, y);
    refreshAllPlotNodeLabels();
    return el.id;
  };

  window.saveScheme = function saveScheme() {
    const scheme = {
      version: 1,
      nextId,
      elements: graph.getElements().map(el => ({
        id: String(el.id),
        type: el.get('blockType'),
        params: el.get('params') || {},
        x: el.position().x,
        y: el.position().y,
        angle: el.angle() || 0
      })),
      links: graph.getLinks().map(l => ({
        source: l.get('source'),
        target: l.get('target')
      }))
    };

    const json = JSON.stringify(scheme, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'scheme.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  window.loadSchemeFromFile = function loadSchemeFromFile(ev) {
    const file = ev && ev.target ? ev.target.files[0] : null;
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const scheme = JSON.parse(reader.result);
        graph.clear();
        selectedNodeId = null;
        selectedNodeIds = new Set();
        try { clearBlockSelection(); } catch(e) {}

        nextId = Math.max(1, parseInt(scheme.nextId || '1', 10));

        // elements
        const idSet = new Set();
        (scheme.elements || []).forEach(e => {
          const el = createBlockCell(e.type, e.x || 50, e.y || 50, e.params || {}, e.id);
          idSet.add(String(el.id));
          if (typeof e.angle === 'number') el.rotate(getAngleSnap(e.angle), true);
          updateLabelUpright(el);
        });

        // links
        (scheme.links || []).forEach(w => {
          if (!w || !w.source || !w.target) return;
          if (!w.source.id || !w.target.id) return;
          const link = paper.options.defaultLink();
          link.source({ id: String(w.source.id), port: w.source.port });
          link.target({ id: String(w.target.id), port: w.target.port });
          link.addTo(graph);
        });

        // Ensure nextId is above max numeric id present
        const nums = Array.from(idSet).map(s => parseInt(s, 10)).filter(n => Number.isFinite(n));
        const maxId = nums.length ? Math.max(...nums) : 0;
        nextId = Math.max(nextId, maxId + 1);

        refreshAllPlotNodeLabels();
      try { updateDisplaysFromLastSim(); } catch(e) {}
      try { refreshAllDisplayNodeLabels(); } catch(e) {}
        renderParamEditor();

        // history: snapshot after load
        try { __pushUndoSnapshot(); } catch(e) {}

      } catch (e) {
        alert('Nelze naƒç√≠st sch√©ma: ' + e);
      }
    };
    reader.readAsText(file);
    ev.target.value = '';
  };

  // Export graph in the SAME structure your /simulate endpoint expects
  window.exportGraph = function exportGraph() {
  const blocks = [];
  const wires = [];

  const elems = graph.getElements();

  // blocks (exclude Plot + Display from simulation)
  elems.forEach(el => {
    const type = el.get('blockType');
    if (type === 'Plot' || type === 'Display') return;
    blocks.push({
      id: String(el.id),
      type,
      params: el.get('params') || {},
      ui: { x: el.position().x, y: el.position().y, rotationDeg: getAngleSnap(el.angle() || 0) }
    });
  });

  // Collect signals requested by Plot and Display
  const plotSignals = [];
  const displaySignals = [];

  elems.forEach(el => {
    const type = el.get('blockType');
    if (type === 'Plot') {
      const p = el.get('params') || {};
      const n = Math.max(1, parseInt(p.n ?? 1, 10) || 1);
      for (let i = 1; i <= n; i++) {
        const port = (n === 1) ? 'u' : ('u' + i);
        const inbound = graph.getConnectedLinks(el, { inbound: true }) || [];
        const link = inbound.find(l => (l.get('target') || {}).port === port);
        if (!link) continue;
        const src = link.get('source') || {};
        if (!src.id || !src.port) continue;
        const srcEl = graph.getCell(String(src.id));
        if (!srcEl || srcEl.get('blockType') === 'Plot' || srcEl.get('blockType') === 'Display') continue;
        plotSignals.push({ plotId: String(el.id), block: String(src.id), port: String(src.port) });
      }
    } else if (type === 'Display') {
      const p = el.get('params') || {};
      const inbound = graph.getConnectedLinks(el, { inbound: true }) || [];
      const link = inbound.find(l => (l.get('target') || {}).port === 'u');
      if (!link) return;
      const src = link.get('source') || {};
      if (!src.id || !src.port) return;
      const srcEl = graph.getCell(String(src.id));
      if (!srcEl || srcEl.get('blockType') === 'Plot' || srcEl.get('blockType') === 'Display') return;
      displaySignals.push({ displayId: String(el.id), block: String(src.id), port: String(src.port) });
    }
  });

  // wires: every link where source/target are NOT Plot/Display
  graph.getLinks().forEach(l => {
    const src = l.get('source') || {};
    const tgt = l.get('target') || {};
    if (!src.id || !src.port || !tgt.id || !tgt.port) return;
    const srcEl = graph.getCell(String(src.id));
    const tgtEl = graph.getCell(String(tgt.id));
    if (!srcEl || !tgtEl) return;
    if (srcEl.get('blockType') === 'Plot' || srcEl.get('blockType') === 'Display') return;
    if (tgtEl.get('blockType') === 'Plot' || tgtEl.get('blockType') === 'Display') return;
    wires.push({
      from: { block: String(src.id), port: String(src.port) },
      to:   { block: String(tgt.id), port: String(tgt.port) }
    });
  });

  // Build scopes from plot+display signals (unique); fallback: Integrator.y
  const scopeSignals =
    ((plotSignals.length || displaySignals.length)
      ? Array.from(new Map(
          [...plotSignals, ...displaySignals].map(s => [`${s.block}.${s.port}`, { block: s.block, port: s.port }])
        ).values())
      : blocks.filter(b => b.type === 'Integrator').map(b => ({ block: b.id, port: 'y' }))
    );

  const scopes = [{ signals: scopeSignals }];

  // Expose display mapping so simulate() can update Display blocks after run
  window.displaySignals = displaySignals;

  const graphOut = { blocks, wires, scopes };
  document.getElementById('jsonOut').textContent = JSON.stringify(graphOut, null, 2);
  return graphOut;
};
  // Compute a stable signature of the current graph relevant for simulation results.
  function __graphSignature() {
    try {
      const g = window.exportGraph();
      // Avoid huge signature differences due to ordering: exportGraph already emits deterministic arrays in creation order.
      return JSON.stringify(g);
    } catch (e) {
      return null;
    }
  }


  // Map server log keys (e.g., "2.y" or "2(TransferFunction).y") to a clear, human-friendly label like "TF (2).y"
  function prettyLabelForLogKey(k) {
    const s = String(k || '');
    let id = null, port = null, typeHint = null;

    let m = s.match(/^(\d+)\([^)]*\)\.([A-Za-z0-9_]+)$/);
    if (m) { id = m[1]; port = m[2]; }

    if (!id) {
      m = s.match(/^(\d+)\.([A-Za-z0-9_]+)$/);
      if (m) { id = m[1]; port = m[2]; }
    }

    if (!id) {
      m = s.match(/^([A-Za-z0-9_]+)\((\d+)\)\.([A-Za-z0-9_]+)$/);
      if (m) { typeHint = m[1]; id = m[2]; port = m[3]; }
    }

    if (!id || !port) return s;

    const n = graph.getCell(String(id));
    const type = n ? n.get('blockType') : (typeHint || 'Block');
    return `${shortTypeName(type)} (${id}).${port}`;
  }

  window.simulate = async function simulate() {
    const graphPayload = window.exportGraph();
    const t0 = parseFloat(document.getElementById('t0').value);
    const t1 = parseFloat(document.getElementById('t1').value);
    const dt = parseFloat(document.getElementById('dt').value);

    const solver = (document.getElementById('solver') && document.getElementById('solver').value) ? document.getElementById('solver').value : 'rk45';
    const payload = { graph: graphPayload, t0, t1, dt, solver };

    try { toggleOutput(true); } catch(e) {}
    document.getElementById('out').textContent = 'Running...';
    if (typeof Plotly !== 'undefined') { try { Plotly.purge('plot'); } catch(e){} }

    try {
      const res = await fetch('/simulate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      let raw = '';
      try { raw = await res.text(); } catch(e) { raw = ''; }

      if (!res.ok) {
        const ct = res.headers.get('content-type') || '';
        document.getElementById('out').textContent =
          `HTTP ${res.status} ${res.statusText}\ncontent-type: ${ct}\n\n` + (raw || '(empty response)');
        return;
      }

      let data;
      try {
        data = JSON.parse(raw);
        __lastSim = data;
        __lastSimSig = __graphSignature();
      } catch(e) {
        document.getElementById('out').textContent = 'OK response but not JSON:\n' + raw;
        return;
      }

      const keys = Object.keys(data.logs || {});
      if (keys.length && typeof Plotly !== 'undefined') {
        const traces = keys.map(k => ({ x: data.t, y: data.logs[k], mode: 'lines', name: prettyLabelForLogKey(k) }));
        Plotly.newPlot('plot', traces, { title: 'Simulation results', xaxis: { title: 't' }, yaxis: { title: 'value' } }, { responsive: true });
        document.getElementById('out').textContent = `success=${data.success}\nmessage=${data.message}`;
      } else {
        let msg = `success=${data.success}\nmessage=${data.message}\n`;
        if (keys.length) {
          const k = keys[0];
          msg += `first log: ${k}\nfirst 5: ${data.logs[k].slice(0,5).join(', ')}\nlast: ${data.logs[k].slice(-1)[0]}`;
        } else {
          msg += 'No logs.';
        }
        document.getElementById('out').textContent = msg;
      }

      refreshAllPlotNodeLabels();
      try { updateDisplaysFromLastSim(); } catch(e) {}
      try { refreshAllDisplayNodeLabels(); } catch(e) {}

    } catch(e) {
      document.getElementById('out').textContent = 'Fetch failed: ' + e;
    }
  };

  // ===== Double-click on Plot block: open its own plot window =====
  // ===== Double-click on Plot block: open its own plot window =====
function openPlotForPlotNode(plotNodeId) {
  const el = graph.getCell(String(plotNodeId));
  if (!el) return;

  const p = el.get('params') || {};
  const label = (typeof p.label === 'string' && p.label.trim()) ? p.label.trim() : `Plot ${plotNodeId}`;
  const n = Math.max(1, parseInt(p.n ?? 1, 10) || 1);

  const titleEl = document.getElementById('plotTitle');
  if (titleEl) titleEl.textContent = label;

  // If we have no simulation yet OR the graph has changed since last simulation, re-run simulate first.
  const curSig = __graphSignature();
  if (!__lastSim || !__lastSim.t || !__lastSim.logs || !__lastSimSig || (curSig && __lastSimSig !== curSig)) {
    try { toggleOutput(true); } catch(e) {}
    window.simulate().then(() => setTimeout(() => openPlotForPlotNode(plotNodeId), 0));
    return;
  }

  const logs = __lastSim.logs || {};
  const keys = Object.keys(logs);
  if (!keys.length) return;

  // Build traces for each connected input
  const traces = [];
  const meta = [];
  for (let i = 1; i <= n; i++) {
    const port = (n === 1) ? 'u' : ('u' + i);
    const inbound = graph.getConnectedLinks(el, { inbound: true }) || [];
    const link = inbound.find(l => (l.get('target') || {}).port === port);
    if (!link) continue;

    const src = link.get('source') || {};
    const srcId = String(src.id || '');
    const srcPort = String(src.port || 'y');
    const srcEl = graph.getCell(srcId);
    const srcType = srcEl ? srcEl.get('blockType') : '';

    const candidates = [
      `${srcId}(${srcType}).${srcPort}`,
      `${srcId}.${srcPort}`
    ];

    const key = candidates.find(k => k in logs) || candidates.find(k => keys.includes(k)) || null;
    if (!key) continue;

    const pretty = `${shortTypeName(srcType)} (${srcId}).${srcPort}`;
    traces.push({ x: __lastSim.t, y: logs[key], mode: 'lines', name: pretty });
    meta.push(`${port}: ${pretty}`);
  }

  const metaEl = document.getElementById('plotMeta');
  if (metaEl) metaEl.textContent = meta.length ? meta.join(' | ') : 'No connected signals.';

  togglePlotWindow(true);
  if (typeof Plotly !== 'undefined') {
    Plotly.newPlot('plotCanvas', traces, { title: label, xaxis: { title: 't' }, yaxis: { title: 'value' } }, { responsive: true });
  }
}

paper.on('element:pointerdblclick', (elementView) => {
    const el = elementView.model;
    if (el && el.get('blockType') === 'Plot') openPlotForPlotNode(String(el.id));
  });


  // ===== Multiple open schemes (tabs) =====
  const __schemes = []; // { name, state }
  let __activeScheme = -1;

  function __captureSchemeState() {
    return { graph: graph.toJSON(), nextId };
  }

  function __restoreSchemeState(state) {
    if (!state) return;
    graph.fromJSON(state.graph || {});
    nextId = Math.max(1, parseInt(state.nextId || '1', 10));
    // Clear selection
    try {
      selectedNodeId = null;
      selectedNodeIds = new Set();
      clearBlockSelection();
      clearSelectedLinks();
      renderParamEditor();
      refreshAllPlotNodeLabels();
      updateDisplaysFromLastSim();
      refreshAllDisplayNodeLabels();
    } catch(e) {}
    try { __pushUndoSnapshot(); } catch(e) {}
  }

  function __renderSchemeTabs() {
    const bar = document.getElementById('schemeTabs');
    if (!bar) return;
    bar.innerHTML = '';

    __schemes.forEach((s, i) => {
      const b = document.createElement('button');
      b.type = 'button';
      b.className = 'stab' + (i === __activeScheme ? ' active' : '');
      const name = (s && s.name) ? String(s.name) : ('Scheme ' + (i + 1));
      b.innerHTML = `<span class="n">${escapeHtml(name)}</span><span class="x" title="Close">√ó</span>`;
      b.addEventListener('click', (ev) => {
        const isClose = ev && ev.target && (ev.target.classList && ev.target.classList.contains('x'));
        if (isClose) {
          ev.preventDefault();
          ev.stopPropagation();
          __closeScheme(i);
          return;
        }
        __switchScheme(i);
      });
      bar.appendChild(b);
    });

    const add = document.createElement('button');
    add.type = 'button';
    add.className = 'stab stabAdd';
    add.textContent = '+ New scheme';
    add.addEventListener('click', () => __newScheme());
    bar.appendChild(add);
  }

  function __switchScheme(i) {
    if (i === __activeScheme) return;
    if (__activeScheme >= 0 && __schemes[__activeScheme]) {
      __schemes[__activeScheme].state = __captureSchemeState();
    }
    __activeScheme = i;
    __restoreSchemeState(__schemes[i].state);
    __renderSchemeTabs();
  }

  function __newScheme() {
    if (__activeScheme >= 0 && __schemes[__activeScheme]) {
      __schemes[__activeScheme].state = __captureSchemeState();
    }
    const name = 'Scheme ' + (__schemes.length + 1);
    const state = { graph: { cells: [] }, nextId: 1 };
    __schemes.push({ name, state });
    __activeScheme = __schemes.length - 1;
    graph.clear();
    nextId = 1;
    try { __pushUndoSnapshot(); } catch(e) {}
    __renderSchemeTabs();
  }

  function __closeScheme(i) {
    if (__schemes.length <= 1) return; // keep at least one
    if (i === __activeScheme) {
      // Close active: switch to neighbor
      const next = (i > 0) ? (i - 1) : 0;
      __schemes.splice(i, 1);
      __activeScheme = Math.min(next, __schemes.length - 1);
      __restoreSchemeState(__schemes[__activeScheme].state);
    } else {
      __schemes.splice(i, 1);
      if (i < __activeScheme) __activeScheme -= 1;
    }
    __renderSchemeTabs();
  }


  // ===== Auto-load default model on load (from default_scheme.json) =====
(async () => {
  try {
    // Uprav si cestu podle toho, kde soubor ve Flasku opravdu serv√≠ruje≈°.
    // Typicky: /static/default_scheme.json
    const res = await fetch('/static/default_scheme.json', { cache: 'no-store' });
    if (!res.ok) throw new Error(`Failed to load default_scheme.json (${res.status})`);

    const scheme = await res.json();

    // 1) Vytvo≈ô bloky a udƒõlej mapov√°n√≠ p≈Øvodn√≠ID -> nov√°ID
    const idMap = new Map();

    for (const el of (scheme.elements || [])) {
      const cell = createBlockCell(el.type, el.x, el.y, el.params || {});
      idMap.set(String(el.id), String(cell.id));

      // pokud podporuje≈° rotaci:
      if (typeof el.angle === 'number' && cell && typeof cell.rotate === 'function') {
        cell.rotate(el.angle, { absolute: true });
      } else if (typeof el.angle === 'number' && cell) {
        // fallback: nƒõkter√© implementace maj√≠ p≈ô√≠mo atribut angle
        try { cell.set('angle', el.angle); } catch (e) {}
      }
    }

    // 2) Vytvo≈ô linky (ignorujeme magnety, d≈Øle≈æit√© jsou id+port)
    for (const ln of (scheme.links || [])) {
      const srcOld = String(ln.source?.id ?? '');
      const tgtOld = String(ln.target?.id ?? '');
      const srcId  = idMap.get(srcOld);
      const tgtId  = idMap.get(tgtOld);

      if (!srcId || !tgtId) {
        console.warn('Skipping link (missing mapped ids):', ln);
        continue;
      }

      const link = paper.options.defaultLink();
      link.source({ id: srcId, port: ln.source.port });
      link.target({ id: tgtId, port: ln.target.port });
      link.addTo(graph);
    }

    refreshAllPlotNodeLabels();
    setStatus('Default scheme loaded: default_scheme.json');

    // Initialize scheme tabs if needed
    if (!__schemes.length) {
      __schemes.push({ name: 'Default', state: __captureSchemeState() });
      __activeScheme = 0;
    } else {
      __schemes[__activeScheme].state = __captureSchemeState();
    }
    __renderSchemeTabs();

    // history: snapshot after default model creation
    try { __pushUndoSnapshot(); } catch (e) {}

  } catch (e) {
    setStatus('JS ERROR while auto-loading default scheme: ' + e);
    console.error(e);
  }

  if (!__schemes.length) {
    __schemes.push({ name: 'Scheme 1', state: __captureSchemeState() });
    __activeScheme = 0;
    __renderSchemeTabs();
  }
  setStatus('Editor started.');
})();
});
</script>
</body>
</html>
