<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulink-lite (Plain HTML) - JointJS</title>

  <!-- JointJS (UMD, no build step) -->
  <link rel="stylesheet" href="/static/joint.min.css">
  <script src="/static/joint.min.js"></script>

  <!-- Plotly (kept as in your Drawflow version) -->
  <script src="/static/plotly-3.3.0.min.js"></script>

  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    .layout { display: grid; grid-template-columns: 260px 1fr; height: 100vh; }
    .panel { border-right: 1px solid #ddd; padding: 12px; overflow: auto; }
    #paperWrap { width: 100%; height: 100%; background: #f6f7f9; outline: none; position: relative;  box-sizing: border-box; }
    .toolbar button { width: 100%; margin: 6px 0; padding: 10px; cursor: pointer; }
    .blockbtn { text-align: left; }
    .kv { display: grid; grid-template-columns: 70px 90px; gap: 8px; }
    .kv label { font-size: 12px; color: #555; }
    input[type="number"], input[type="text"] { width: 100%; padding: 6px; }
    pre { white-space: pre-wrap; word-break: break-word; background:#111; color:#ddd; padding:10px; border-radius:8px; }
    .hint { font-size: 12px; color:#666; line-height: 1.4; }

    /* Floating panels (Output + Plot) */
    .floating-panel {
      position: fixed;
      top: 60px;
      right: 18px;
      width: 360px;
      max-height: calc(100vh - 90px);
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.18);
      z-index: 9999;
      display: none;
      overflow: hidden;
    }
    .floating-panel.show { display: block; }

    .fp-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      cursor: move;
      user-select:none;
      background:#f3f4f6;
      border-bottom:1px solid #e5e7eb;
      font-weight:700;
    }
    .fp-header .fp-actions{ display:flex; gap:8px; }
    .fp-btn{
      border:1px solid #d1d5db;
      background:#fff;
      border-radius:10px;
      padding:6px 10px;
      cursor:pointer;
      font-weight:600;
    }
    .fp-btn:hover{ background:#f9fafb; }

    .fp-body{
      padding:12px;
      overflow:auto;
      max-height: calc(100vh - 150px);
    }

    /* Plot window is wider */
    #plotWindow.floating-panel{ width: 560px; }
    #plotCanvas{ height: 360px; }

    /* Left panel selection editor */
    .section-title{ margin: 14px 0 8px; font-size: 14px; font-weight: 800; }

    /* Collapsible block categories */
    .blockcats details.cat { margin: 6px 0; }
    .blockcats details.cat summary { cursor: pointer; user-select: none; font-weight: 600; }
    .blockcats details.cat summary::-webkit-details-marker { display: none; }
    .blockcats details.cat summary::before { content: "‚ñæ"; display: inline-block; width: 18px; }
    .blockcats details.cat:not([open]) summary::before { content: "‚ñ∏"; }
    .blockcats details.cat .toolbar { margin-top: 6px; }

    /* JointJS paper tweaks */
    #paperWrap .joint-paper { background: transparent !important; }
    /* Make ports sit above links */
    .joint-port-body { pointer-events: all; }

  
/* === UX: small crosshair cursor on ports / nodes === */
.joint-port,
.joint-port * {
    cursor: crosshair !important;
}

.joint-element {
    cursor: default;
}

.joint-element .joint-port {
    cursor: crosshair;
}


/* Ensure the larger invisible port hit area can capture pointer events */
.joint-port-hit { pointer-events: all; }


/* Keep port hit-ring invisible even when JointJS applies magnet highlighting */
.joint-port-hit,
.joint-port-hit * {
    stroke: transparent !important;
    fill: none !important;
}


/* === Selected block highlight (backup CSS if needed) === */
.joint-cell.selected-block rect,
.joint-cell.selected-block .body {
  stroke: #8b5cf6 !important;
  stroke-width: 3 !important;
  fill: #f5f3ff !important;
}


/* === Box selection rectangle === */
#paperWrap .box-select-rect{
  position:absolute;
  border:1px dashed #8b5cf6;
  background: rgba(139, 92, 246, 0.10);
  pointer-events:none;
  z-index: 10000;
}

</style>
</head>
<body>
<div class="layout">
  <!-- Left panel -->
  <div class="panel">
    <h3>Blocks</h3>
    <div class="blockcats">
      <details class="cat">
        <summary>Sources</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('Constant')">+ Constant</button>
        </div>
      </details>

      <details class="cat">
        <summary>Math</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('Gain')">+ Gain</button>
          <button class="blockbtn" onclick="addBlock('Sum')">+ Sum (u1,u2)</button>
        </div>
      </details>

      <details class="cat">
        <summary>Models</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('TransferFunction')">+ Transfer Function</button>
          <button class="blockbtn" onclick="addBlock('Integrator')">+ Integrator</button>
        </div>
      </details>


      <details class="cat">
        <summary>Discontinuities</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('Saturation')">+ Saturation</button>
        </div>
      </details>

      <details class="cat">
        <summary>Sinks</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('Plot')">+ Plot</button>
        </div>
      </details>
    </div>

    <hr>

    <h3>Sch√©ma</h3>
    <button onclick="saveScheme()">üíæ Ulo≈æit sch√©ma</button>
    <input type="file" id="loadSchemeInput" accept="application/json" style="display:none" onchange="loadSchemeFromFile(event)">
    <button onclick="document.getElementById('loadSchemeInput').click()">üìÇ Otev≈ô√≠t sch√©ma</button>

    <hr>

    <h3>Run</h3>
    <div class="kv">
      <label>t0</label><input id="t0" type="number" value="0" step="0.1">
      <label>t1</label><input id="t1" type="number" value="5" step="0.1">
      <label>dt</label><input id="dt" type="number" value="0.1" step="0.01">
    </div>

    <div class="section-title">Selected block</div>
    <div id="selectedInfo" class="hint">Nothing selected.</div>
    <div id="paramEditor"></div>

    <button onclick="exportGraph()">Export JSON</button>
    <button onclick="simulate()">Simulate</button>
    <button id="toggleOutputBtn" style="margin-top:10px;" onclick="toggleOutput()">Show Output (F2)</button>

    <p class="hint">
      Tip: Klikni na blok pro editaci parametr≈Ø vlevo. Propoj porty ta≈æen√≠m z v√Ωstupu do vstupu. Dvojklik na dr√°t p≈ôid√° zlom (vertex), kter√Ω lze t√°hnout. Nav√≠c: m≈Ø≈æe≈° chytnout dr√°t kdekoliv a tahem vytvo≈ôit/posunout zlom.
      <br><br>
      MVP pravidla: 1 dr√°t na 1 vstup. ≈Ω√°dn√© ƒçistƒõ algebraick√© cykly.
    </p>
  </div>

  <!-- Canvas -->
  <div id="paperWrap" tabindex="0"></div>
</div>

<!-- Floating Output Panel (toggle with button/F2) -->
<div id="outputWindow" class="floating-panel" aria-hidden="true">
  <div class="fp-header" id="outputHeader">
    <span>Output</span>
    <div class="fp-actions">
      <button class="fp-btn" onclick="toggleOutput(false)">Close</button>
    </div>
  </div>
  <div class="fp-body">
    <div id="jsStatus" class="hint">JS not started yet.</div>
    <div id="plot" style="height:240px;"></div>
    <div id="out" class="hint">‚Äî</div>
    <h4>Last exported JSON</h4>
    <pre id="jsonOut">{}</pre>
  </div>
</div>

<!-- Floating Plot Window (opened by double-click on Plot block) -->
<div id="plotWindow" class="floating-panel" aria-hidden="true">
  <div class="fp-header" id="plotHeader">
    <span id="plotTitle">Plot</span>
    <div class="fp-actions">
      <button class="fp-btn" onclick="togglePlotWindow(false)">Close</button>
    </div>
  </div>
  <div class="fp-body">
    <div id="plotCanvas"></div>
    <div id="plotMeta" class="hint" style="margin-top:8px;"></div>
  </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  const jsStatusEl = document.getElementById('jsStatus');
  const setStatus = (t) => { if (jsStatusEl) jsStatusEl.textContent = t; };

  // ===== Floating window helpers =====
  function toggleOutput(force) {
    const w = document.getElementById('outputWindow');
    const btn = document.getElementById('toggleOutputBtn');
    if (!w) return;
    const show = (typeof force === 'boolean') ? force : !w.classList.contains('show');
    w.classList.toggle('show', show);
    w.setAttribute('aria-hidden', show ? 'false' : 'true');
    if (btn) btn.textContent = show ? 'Hide Output (F2)' : 'Show Output (F2)';
  }

  function togglePlotWindow(force) {
    const w = document.getElementById('plotWindow');
    if (!w) return;
    const show = (typeof force === 'boolean') ? force : !w.classList.contains('show');
    w.classList.toggle('show', show);
    w.setAttribute('aria-hidden', show ? 'false' : 'true');
    if (!show && typeof Plotly !== 'undefined') { try { Plotly.purge('plotCanvas'); } catch(e){} }
  }

  window.toggleOutput = toggleOutput;
  window.togglePlotWindow = togglePlotWindow;

  function makeDraggable(winEl, headerEl) {
    let dragging = false, startX = 0, startY = 0, origX = 0, origY = 0;

    const onDown = (e) => {
      if (e.target && e.target.closest && e.target.closest('button')) return;
      dragging = true;
      const r = winEl.getBoundingClientRect();
      origX = r.left; origY = r.top;
      startX = e.clientX; startY = e.clientY;
      winEl.style.left = origX + 'px';
      winEl.style.top = origY + 'px';
      winEl.style.right = 'auto';
      e.preventDefault();
    };

    const onMove = (e) => {
      if (!dragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      winEl.style.left = (origX + dx) + 'px';
      winEl.style.top  = (origY + dy) + 'px';
    };

    const onUp = () => { dragging = false; };

    headerEl.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }

  // F2 toggles Output window
  document.addEventListener('keydown', (e) => {
    if (e.key === 'F2') {
      e.preventDefault();
      toggleOutput();
    }
  });

  setTimeout(() => {
    const ow = document.getElementById('outputWindow');
    const oh = document.getElementById('outputHeader');
    const pw = document.getElementById('plotWindow');
    const ph = document.getElementById('plotHeader');
    if (ow && oh) makeDraggable(ow, oh);
    if (pw && ph) makeDraggable(pw, ph);
    toggleOutput(false);
    togglePlotWindow(false);
  }, 0);

  // Store last simulation response for Plot double-click
  let __lastSim = null;
  let __lastSimSig = null; // signature of graph used for __lastSim


  window.onerror = function(msg, url, line, col, err) {
    setStatus('JS ERROR: ' + msg + ' (line ' + line + ')');
  };

  if (typeof joint === 'undefined' || !joint.dia) {
    setStatus('JointJS is NOT defined. Check CDN availability.');
    return;
  }

  setStatus('JS started. Initializing JointJS editor...');

  // ---- Block library: ports + default params ----
  const BLOCK_LIBRARY = {
    Constant:   { inputs: [], outputs: ['y'], defaultParams: { value: 1.0 }, desc: 'constant source' },
    Gain:       { inputs: ['u'], outputs: ['y'], defaultParams: { k: 1.0 }, desc: 'multiply input' },
    Sum:        { inputs: ['u1','u2'], outputs: ['y'], defaultParams: { signs: '++' }, desc: 'sum inputs' },
    Integrator: { inputs: ['u'], outputs: ['y'], defaultParams: { x0: 0.0 }, desc: '‚à´ u dt' },
    Saturation: { inputs: ['u'], outputs: ['y'], defaultParams: { lower: -1.0, upper: 1.0 }, desc: 'limit signal to [lower, upper]' },
    Plot:       { inputs: ['u'], outputs: [], defaultParams: { label: '' }, desc: 'signal scope' },
    TransferFunction: { inputs: ['u'], outputs: ['y'], defaultParams: { num: '1', den: '1,1' }, desc: 'continuous LTI system' },
  };

  // ---- Short display names (canvas titles) ----
  const SHORT_NAMES = {
    Constant: 'Const',
    TransferFunction: 'TF',
    Integrator: 'Int',
    Gain: 'Gain',
    Sum: 'Sum',
    Saturation: 'Sat',
    Plot: 'Plot'
  };
  function shortTypeName(type) { return SHORT_NAMES[type] || type; }

  // ===== JointJS graph + paper =====
  const namespace = joint.shapes;
  const graph = new joint.dia.Graph({}, { cellNamespace: namespace });

  // ===== Undo/Redo (CTRL+Z / CTRL+Y, multiple steps) =====
  const __UNDO_MAX = 80;
  let __undoStack = [];
  let __redoStack = [];
  let __histLock = false;      // prevents recording during restore
  let __histTimer = null;

  function __pushUndoSnapshot() {
    if (__histLock) return;
    try {
      const snap = graph.toJSON();
      const last = __undoStack.length ? __undoStack[__undoStack.length - 1] : null;
      const s1 = JSON.stringify(snap);
      const s0 = last ? JSON.stringify(last) : null;
      if (s0 === s1) return; // avoid duplicates
      __undoStack.push(snap);
      if (__undoStack.length > __UNDO_MAX) __undoStack.shift();
      // any new change invalidates redo stack
      __redoStack = [];
    } catch (e) {
      // ignore
    }
  }

  function __scheduleSnapshot() {
    if (__histLock) return;
    if (__histTimer) clearTimeout(__histTimer);
    __histTimer = setTimeout(() => {
      __histTimer = null;
      __pushUndoSnapshot();
    }, 220);
  }

  function __restoreSnapshot(snap) {
    if (!snap) return;
    __histLock = true;
    try {
      // Restore full graph (cells + links)
      graph.fromJSON(snap);

      // Clear selection states (views will be recreated)
      try {
        selectedNodeId = null;
        selectedNodeIds = new Set();
        clearBlockSelection();
        renderParamEditor();
      } catch(e) {}

      try { setSelectedLink(null); } catch(e) {}
      try { refreshAllPlotNodeLabels(); } catch(e) {}
    } finally {
      __histLock = false;
    }
  }

  function undo() {
    if (__histLock) return;
    if (__undoStack.length <= 1) return; // keep at least one (current) snapshot
    const current = __undoStack.pop();
    __redoStack.push(current);
    const prev = __undoStack[__undoStack.length - 1];
    __restoreSnapshot(prev);
  }

  function redo() {
    if (__histLock) return;
    if (!__redoStack.length) return;
    const next = __redoStack.pop();
    __undoStack.push(next);
    __restoreSnapshot(next);
  }

  // Record history on *any* graph structural or attribute change (debounced)
  graph.on('add remove change', (cell, opt = {}) => {
    if (opt && opt.skipHistory) return;
    __scheduleSnapshot();
  });

  // Keyboard bindings
  document.addEventListener('keydown', (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
    const isTyping = (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (e.target && e.target.isContentEditable));
    if (isTyping) return;

    const key = (e.key || '').toLowerCase();

    // Ctrl+Z => Undo, Ctrl+Shift+Z or Ctrl+Y => Redo
    if (e.ctrlKey && !e.altKey && key === 'z') {
      e.preventDefault();
      if (e.shiftKey) redo();
      else undo();
    } else if (e.ctrlKey && !e.altKey && key === 'y') {
      e.preventDefault();
      redo();
    }
  }, true);

  // Initialize with an initial snapshot (empty graph; will be updated after default model is added)
  __pushUndoSnapshot();



  

    // ===== Delete key: remove selected link or selected block(s) (and connected links) =====
  document.addEventListener('keydown', (e) => {
    if (e.key !== 'Delete' && e.key !== 'Backspace') return;

    // Don't hijack Delete/Backspace while typing in inputs/textareas or editable elements.
    const ae = document.activeElement;
    if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) return;

    // Prefer deleting selected link if any
    if (typeof selectedLinkId !== 'undefined' && selectedLinkId) {
      const l = graph.getCell(selectedLinkId);
      if (l) l.remove();
      if (typeof setSelectedLink === 'function') setSelectedLink(null);
      e.preventDefault();
      return;
    }

    // Delete selected nodes (multi-select supported)
    const ids = (typeof selectedNodeIds !== 'undefined' && selectedNodeIds && selectedNodeIds.size)
      ? Array.from(selectedNodeIds).map(String)
      : (typeof selectedNodeId !== 'undefined' && selectedNodeId ? [String(selectedNodeId)] : []);

    if (!ids.length) return;

    // Remove connected links first, then nodes
    ids.forEach(id => {
      const el = graph.getCell(String(id));
      if (!el) return;
      const links = graph.getConnectedLinks(el);
      links.forEach(link => link.remove());
      el.remove();
    });

    // Clear selection
    if (typeof selectedNodeId !== 'undefined') selectedNodeId = null;
    if (typeof selectedNodeIds !== 'undefined') selectedNodeIds = new Set();
    try { clearBlockSelection(); } catch(e) {}
    try { renderParamEditor(); } catch(e) {}
    try { refreshAllPlotNodeLabels(); } catch(e) {}

    e.preventDefault();
  }, true);
const wrap = document.getElementById('paperWrap');
  
  // ===== Connection validation (Simulink-style) =====
  function __getPortGroup(m) {
    if (!m) return null;
    return m.getAttribute('port-group') ||
           (m.closest && (m.closest('[port-group]') && m.closest('[port-group]').getAttribute('port-group'))) ||
           (m.closest && (m.closest('.joint-port') && m.closest('.joint-port').getAttribute('port-group'))) ||
           null;
  }
const paper = new joint.dia.Paper({
    // Only allow starting a wire from OUT ports (ports have port-group="out")
    validateMagnet: function(cellView, magnet) {
      return __getPortGroup(magnet) === 'out';
    },

    // Enforce OUT ‚Üí IN and forbid connecting to blocks without any IN ports.
    validateConnection: function(srcView, srcMagnet, tgtView, tgtMagnet) {
      // If no target magnet, connection is invalid (dropping on element body / blank)
      if (!tgtMagnet || !tgtView || !tgtView.model) return false;

      // Must be from OUT port
      if (__getPortGroup(srcMagnet) !== 'out') return false;

      // Must be to IN port
      if (__getPortGroup(tgtMagnet) !== 'in') return false;

      // Target element must have at least one input port group 'in'
      const ports = (tgtView.model.getPorts) ? tgtView.model.getPorts() : [];
      const hasInput = ports.some(p => p.group === 'in');
      if (!hasInput) return false;

      return true;
    },

    el: wrap,
    model: graph,
    gridSize: 20,
    drawGrid: true,
    async: true,
    background: { color: 'transparent' },
    cellViewNamespace: namespace,
    defaultLink: () => {
      const l = new joint.shapes.standard.Link();
      l.attr({
        line: {
          stroke: '#4a90e2',
          strokeWidth: 2.2,
          targetMarker: { type: 'path', d: 'M 10 -5 0 0 10 5 z' }
        }
      });

  l.router('manhattan', { step: 20, padding: 12 });
      l.connector('rounded', { radius: 8 });
      return l;
    },
    interactive: function(cellView) {
      // allow moving elements and manipulating links
      if (cellView.model.isLink()) return { vertexAdd: true, vertexMove: true, vertexRemove: true };
      return true;
    },
    linkPinning: false,
    snapLinks: { radius: 30 },
    markAvailable: true
  });

  // ===== Viewport interactions (zoom/pan/box-select) =====
  // (Moved out of defaultLink() to avoid registering listeners repeatedly.)
// ===== Diagram zoom (paper scale) with CTRL + mouse wheel =====
    // Zooms the JointJS paper only (not the whole page). Keeps the point under cursor stable.
    let __paperScale = { x: 1, y: 1 };
    const __ZOOM_MIN = 0.35;
    const __ZOOM_MAX = 2.5;
    const __ZOOM_STEP = 1.12; // per wheel notch
  
    function __clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  
    function __setPaperScaleAroundClientPoint(newS, clientPt) {
      // Keep cursor position stable: adjust translate based on local point before/after scaling.
      const before = paper.clientToLocalPoint(clientPt);
  
      paper.scale(newS, newS);
      __paperScale = { x: newS, y: newS };
  
      const after = paper.clientToLocalPoint(clientPt);
  
      const dx = (after.x - before.x) * newS;
      const dy = (after.y - before.y) * newS;
  
      const t = paper.translate();
      paper.translate((t.tx || 0) + dx, (t.ty || 0) + dy);
    }
  
    wrap.addEventListener('wheel', (e) => {
      if (!e.ctrlKey) return;              // only CTRL + wheel
      e.preventDefault();                  // prevent browser zoom
      e.stopPropagation();
  
      const dir = (e.deltaY < 0) ? 1 : -1; // wheel up => zoom in
      const factor = (dir > 0) ? __ZOOM_STEP : (1 / __ZOOM_STEP);
      const next = __clamp(__paperScale.x * factor, __ZOOM_MIN, __ZOOM_MAX);
  
      __setPaperScaleAroundClientPoint(next, { x: e.clientX, y: e.clientY });
    }, { passive: false });
  
  
        
  
    // ===== UX: Pan the whole diagram with RIGHT mouse button (DOM-based, reliable) =====
    // Right-drag on empty canvas pans the paper. Left button stays for selection/move.
    let __panning = false;
    let __panStartClient = { x: 0, y: 0 };
    let __panStartTranslate = { x: 0, y: 0 };
  
    // Disable browser context menu on canvas so RMB drag works everywhere
    wrap.addEventListener('contextmenu', (e) => e.preventDefault());
  
    function __isInteractiveTarget(t) {
      // If user right-clicks a block/link/port, don't pan (avoid conflicts)
      return !!(t && (t.closest('.joint-element') || t.closest('.joint-link') || t.closest('.joint-port')));
    }
  
    wrap.addEventListener('mousedown', (e) => {
      if (e.button !== 2) return;                // 2 = right mouse button
      if (__isInteractiveTarget(e.target)) return;
  
      __panning = true;
      __panStartClient = { x: e.clientX, y: e.clientY };
      const tr = paper.translate();
      __panStartTranslate = { x: tr.tx || 0, y: tr.ty || 0 };
  
      e.preventDefault();
      e.stopPropagation();
    }, true);
  
    window.addEventListener('mousemove', (e) => {
      if (!__panning) return;
      const dx = e.clientX - __panStartClient.x;
      const dy = e.clientY - __panStartClient.y;
      paper.translate(__panStartTranslate.x + dx, __panStartTranslate.y + dy);
      e.preventDefault();
    }, true);
  
    window.addEventListener('mouseup', (e) => {
      if (e.button !== 2) return;
      __panning = false;
    }, true);
  
    
    // ===== LMB drag: box selection of multiple blocks (marquee) =====
    // Drag on empty canvas (left button) draws a rectangle and selects intersecting blocks.
    let __boxSel = null; // { startClient:{x,y}, rectEl }
    function __clientRectToLocalRect(c0, c1) {
      const p0 = paper.clientToLocalPoint(c0);
      const p1 = paper.clientToLocalPoint(c1);
      const x1 = Math.min(p0.x, p1.x), y1 = Math.min(p0.y, p1.y);
      const x2 = Math.max(p0.x, p1.x), y2 = Math.max(p0.y, p1.y);
      return { x: x1, y: y1, width: (x2 - x1), height: (y2 - y1) };
    }
    function __rectsIntersect(a, b) {
      return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
    }
    function __isBlankTarget(t) {
      // Only start box selection when clicking on empty background, not on elements/links/ports.
      return !(t && (t.closest('.joint-element') || t.closest('.joint-link') || t.closest('.joint-port')));
    }
  
    wrap.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // left only
      if (!__isBlankTarget(e.target)) return;
  
      __boxSel = { startClient: { x: e.clientX, y: e.clientY }, rectEl: null };
  
      const r = document.createElement('div');
      r.className = 'box-select-rect';
      r.style.left = '0px';
      r.style.top = '0px';
      r.style.width = '0px';
      r.style.height = '0px';
      wrap.appendChild(r);
      __boxSel.rectEl = r;
  
      // Clear selection at start of box select
      selectedNodeId = null;
      selectedNodeIds = new Set();
      clearBlockSelection();
      renderParamEditor();
  
      e.preventDefault();
    }, true);
  
    window.addEventListener('mousemove', (e) => {
      if (!__boxSel) return;
      const x0 = __boxSel.startClient.x, y0 = __boxSel.startClient.y;
      const x1 = e.clientX, y1 = e.clientY;
  
      const left = Math.min(x0, x1), top = Math.min(y0, y1);
      const w = Math.abs(x1 - x0), h = Math.abs(y1 - y0);
  
      if (__boxSel.rectEl) {
        const wrapRect = wrap.getBoundingClientRect();
        __boxSel.rectEl.style.left = (left - wrapRect.left) + 'px';
        __boxSel.rectEl.style.top = (top - wrapRect.top) + 'px';
        __boxSel.rectEl.style.width = w + 'px';
        __boxSel.rectEl.style.height = h + 'px';
      }
    }, true);
  
    window.addEventListener('mouseup', (e) => {
      if (!__boxSel) return;
  
      const c0 = __boxSel.startClient;
      const c1 = { x: e.clientX, y: e.clientY };
      const selLocal = __clientRectToLocalRect(c0, c1);
  
      const hits = [];
      graph.getElements().forEach(el => {
        const bb = el.getBBox(); // paper local coords
        const r = { x: bb.x, y: bb.y, width: bb.width, height: bb.height };
        if (__rectsIntersect(selLocal, r)) hits.push(String(el.id));
      });
  
      selectedNodeIds = new Set(hits);
      selectedNodeId = (hits.length === 1) ? hits[0] : null;
      setSelectedBlocks(selectedNodeIds);
      renderParamEditor();
  
      if (__boxSel.rectEl && __boxSel.rectEl.parentNode) __boxSel.rectEl.parentNode.removeChild(__boxSel.rectEl);
      __boxSel = null;
    }, true);

  // === Port positioning: tangent to block edge (circle edge touches the block edge) ===
  // We keep the visual port radius = 7, but shift the port CENTER inward by 7px.
  const PORT_RADIUS = 7;     // must match portBody r
  const PORT_INSET  = PORT_RADIUS;

  function leftInsetPositioner(ports, elBBox /*, opt */) {
    const n = ports.length || 1;
    const pad = 14; // vertical padding inside the block
    const h = Math.max(1, elBBox.height - 2 * pad);
    return ports.map((p, i) => ({
      x: elBBox.x - PORT_INSET,
      y: elBBox.y + pad + (n === 1 ? h / 2 : (h * i) / (n - 1))
    }));
  }

  function rightInsetPositioner(ports, elBBox /*, opt */) {
    const n = ports.length || 1;
    const pad = 14;
    const h = Math.max(1, elBBox.height - 2 * pad);
    return ports.map((p, i) => ({
      x: elBBox.x + elBBox.width + PORT_INSET,
      y: elBBox.y + pad + (n === 1 ? h / 2 : (h * i) / (n - 1))
    }));
  }


  function fitPaper() {
    // Force paper to occupy the full remaining right side (window width minus left panel).
    const panel = document.querySelector('.panel');
    const leftW = panel ? panel.getBoundingClientRect().width : 260;
    const w = Math.max(200, window.innerWidth - leftW);
    const h = Math.max(200, window.innerHeight);
    // Ensure the wrapper itself is sized deterministically
    wrap.style.width = w + 'px';
    wrap.style.height = h + 'px';
    paper.setDimensions(w, h);
  }
  window.addEventListener('resize', fitPaper);
  setTimeout(() => fitPaper(), 0);
  requestAnimationFrame(() => fitPaper());
// ===== Ports config =====
  const PORT_MARKUP = [
    // Larger invisible hit area so the user can reliably start a connection
    { tagName: 'circle', selector: 'portHit', attributes: { r: 7, fill: 'none', stroke: 'transparent', 'stroke-width': 18, 'pointer-events': 'stroke', class: 'joint-port-hit' } },
    { tagName: 'circle', selector: 'portBody', attributes: { r: 7, class: 'joint-port-body' } },
    // Let clicks go through the text to the magnet circle(s)
    { tagName: 'text', selector: 'portArrow', attributes: { 'font-size': 11, 'font-weight': 900, 'text-anchor': 'middle', 'y': 4, 'pointer-events': 'none' } }
  ];

  const portGroups = {
    in: {
      position: leftInsetPositioner,

      attrs: {
        portHit: { magnet: 'passive' },
        portBody: { fill: '#f5a3c7', stroke: '#d86aa0', magnet: 'passive' },
        portArrow: { text: '‚ñ∂', fill: '#000', x: 0 }
      },
      markup: PORT_MARKUP,
      label: { position: { name: 'left', args: { y: 0 } }, markup: [] }
    },
    out: {
      position: rightInsetPositioner,

      attrs: {
        portHit: { magnet: true },
        portBody: { fill: '#9ecbff', stroke: '#4a90e2', magnet: true },
        portArrow: { text: '‚ñ∂', fill: '#000', x: 0 }
      },
      markup: PORT_MARKUP,
      label: { position: { name: 'right', args: { y: 0 } }, markup: [] }
    }
  };

  // ===== Node HTML (kept: title + desc + paramsLine) =====
  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#039;');
  }

  function formatParamsLine(type, params, meta) {
    const spec = BLOCK_LIBRARY[type] || {};
    const defaults = spec.defaultParams || {};

    if (type === 'Plot') {
      const sig = (meta && meta.signalPretty) ? String(meta.signalPretty) : '';
      const lbl = (params && typeof params.label === 'string') ? params.label.trim() : '';
      if (lbl && sig && lbl !== sig) return `${lbl} ‚Äî ${sig}`;
      if (lbl) return lbl;
      if (sig) return sig;
      return '(not connected)';
    }
    if (type === 'Constant')   return `value=${(params && params.value !== undefined) ? params.value : defaults.value}`;
    if (type === 'Gain')       return `k=${(params && params.k !== undefined) ? params.k : defaults.k}`;
    if (type === 'Sum')        return `signs=${(params && params.signs !== undefined) ? params.signs : defaults.signs}`;
    if (type === 'Integrator') return `x0=${(params && params.x0 !== undefined) ? params.x0 : defaults.x0}`;
    if (type === 'Saturation') {
      const lo = (params && params.lower !== undefined) ? params.lower : defaults.lower;
      const hi = (params && params.upper !== undefined) ? params.upper : defaults.upper;
      return `lower=${lo}, upper=${hi}`;
    }
    if (type === 'TransferFunction') {
      const num = (params && params.num !== undefined) ? params.num : defaults.num;
      const den = (params && params.den !== undefined) ? params.den : defaults.den;
      return `num=${num}, den=${den}`;
    }

    const parts = [];
    for (const k of Object.keys(defaults)) {
      const cur = (params && params[k] !== undefined) ? params[k] : defaults[k];
      parts.push(`${k}=${cur}`);
    }
    return parts.join(', ');
  }

  function computePlotSignalPretty(plotId) {
    const plotEl = graph.getCell(String(plotId));
    if (!plotEl) return '';

    // incoming link to Plot.u
    const inbound = graph.getConnectedLinks(plotEl, { inbound: true });
    const link = inbound.find(l => (l.get('target') || {}).port === 'u');
    if (!link) return '';

    const src = link.get('source') || {};
    const srcId = String(src.id || '');
    const srcPort = String(src.port || 'y');
    const srcEl = graph.getCell(srcId);
    const srcType = srcEl ? srcEl.get('blockType') : '';

    return `${shortTypeName(srcType)} (${srcId}).${srcPort}`;
  }

  function blockText(type, id, params) {
    const shown = shortTypeName(type);
    const title = `${shown} (${id})`;
    const desc = (BLOCK_LIBRARY[type] && typeof BLOCK_LIBRARY[type].desc === 'string') ? BLOCK_LIBRARY[type].desc : '';

    let sigPretty = '';
    if (type === 'Plot') sigPretty = computePlotSignalPretty(id) || '';
    const line = formatParamsLine(type, params || {}, { signalPretty: sigPretty });

    // Using SVG <text> multiline (\n). JointJS splits lines.
    const parts = [title];
    if (desc) parts.push(desc);
    if (line) parts.push(line);
    return parts.join('\n');
  }

  // ===== Create blocks =====
  let nextId = 1;
  function allocId() { return String(nextId++); }

  

// ===== Keep block text upright (do not rotate label with the element) =====
function updateLabelUpright(el) {
  if (!el || el.isLink && el.isLink()) return;
  const a = (typeof el.angle === 'function') ? (el.angle() || 0) : 0;
  const sz = (typeof el.size === 'function') ? el.size() : { width: 0, height: 0 };
  // Label is centered inside the element by default; rotate around element center in local coords
  const cx = (sz.width || 0) / 2;
  const cy = (sz.height || 0) / 2;
  if (!a) {
    el.attr('label/transform', null);
  } else {
    el.attr('label/transform', `rotate(${-a}, ${cx}, ${cy})`);
  }
}

// ===== Auto-swap element size for 90¬∞/270¬∞ so the (upright) label stays inside =====
function ensureSizeMatchesAngle(el) {
  if (!el || (el.isLink && el.isLink())) return;
  if (el.get && el.get('__swappingSize')) return;

  const a = (typeof el.angle === 'function') ? (el.angle() || 0) : 0;
  const ang = (((a % 360) + 360) % 360);
  const base = (el.get && el.get('baseSize')) ? el.get('baseSize') : (typeof el.size === 'function' ? el.size() : { width: 0, height: 0 });

  const wantSwap = (ang === 90 || ang === 270);
  const target = wantSwap ? { width: base.height, height: base.width } : { width: base.width, height: base.height };

  const cur = (typeof el.size === 'function') ? el.size() : { width: 0, height: 0 };
  if (cur.width === target.width && cur.height === target.height) return;

  // Guard against resize->change:size loops
  if (el.set) el.set('__swappingSize', true, { silent: true });
  if (typeof el.resize === 'function') el.resize(target.width, target.height);
  if (el.unset) el.unset('__swappingSize', { silent: true });
}

// Track "baseSize" as the unrotated size (0¬∞/180¬∞). If resized while rotated,
// we still keep baseSize in unrotated orientation so swapping stays consistent.
function updateBaseSize(el) {
  if (!el || (el.isLink && el.isLink())) return;
  if (el.get && el.get('__swappingSize')) return;

  const a = (typeof el.angle === 'function') ? (el.angle() || 0) : 0;
  const ang = (((a % 360) + 360) % 360);
  const sz = (typeof el.size === 'function') ? el.size() : { width: 0, height: 0 };
  const base = (ang === 90 || ang === 270) ? { width: sz.height, height: sz.width } : { width: sz.width, height: sz.height };
  if (el.set) el.set('baseSize', base, { silent: true });
}

// Keep label upright & size consistent whenever the element rotates or resizes.
graph.on('change:angle', (cell) => {
  if (!cell || cell.isLink && cell.isLink()) return;
  ensureSizeMatchesAngle(cell);
  updateLabelUpright(cell);
});
graph.on('change:size', (cell) => {
  if (!cell || cell.isLink && cell.isLink()) return;
  updateBaseSize(cell);
  updateLabelUpright(cell);
});

// Keep label upright whenever the element rotates (or is resized).

  function createBlockCell(type, x, y, params, forcedId) {
    const spec = BLOCK_LIBRARY[type];
    if (!spec) throw new Error('Unknown type: ' + type);

    const id = forcedId ? String(forcedId) : allocId();
    const p = params ? JSON.parse(JSON.stringify(params)) : JSON.parse(JSON.stringify(spec.defaultParams));

    const el = new joint.shapes.standard.Rectangle({
      id,
      blockType: type,
      params: p
    });

    el.position(x, y);
    el.resize(170, 76);
    el.set('baseSize', { width: 170, height: 76 }, { silent: true });

    el.attr({
      body: {
        magnet: false,
        rx: 10, ry: 10,
        stroke: '#b8c0cc',
        strokeWidth: 1.2,
        fill: '#ffd1c8'
      },
      label: {
        magnet: false,
        text: blockText(type, id, p),
        fill: '#111',
        fontSize: 12,
        fontFamily: 'Arial, sans-serif',
        textWrap: { width: -10, height: -10 }
      }
    });

    // ports
    el.set('ports', { groups: portGroups, items: [] });
    const inPorts  = spec.inputs.map(name => ({ id: name, group: 'in' }));
    const outPorts = spec.outputs.map(name => ({ id: name, group: 'out' }));
    el.addPorts([...inPorts, ...outPorts]);

    el.addTo(graph);
    updateLabelUpright(el);
    return el;
  }

  function refreshBlockText(id) {
    const el = graph.getCell(String(id));
    if (!el || el.isLink()) return;
    const type = el.get('blockType');
    const params = el.get('params') || {};
    el.attr('label/text', blockText(type, String(id), params));
  }

  // ===== Selection + param editor =====
  let selectedNodeId = null;
  let selectedNodeIds = new Set();

  // --- Visual highlight for selected block (reliable via model attrs) ---
  const __SEL_STYLE = { stroke: '#8b5cf6', strokeWidth: 3, fill: '#f5f3ff' };

  function __applySelectionStyle(el, on) {
    if (!el || (el.isLink && el.isLink())) return;
    // Cache original style once
    const cached = el.get('__origBodyStyle');
    if (!cached) {
      const a = (el.attr('body') || {});
      el.set('__origBodyStyle', {
        stroke: a.stroke ?? '#b8c0cc',
        strokeWidth: a.strokeWidth ?? 1.2,
        fill: a.fill ?? '#ffd1c8'
      }, { silent: true });
    }
    const orig = el.get('__origBodyStyle') || { stroke:'#b8c0cc', strokeWidth:1.2, fill:'#ffd1c8' };
    el.attr('body/stroke', on ? __SEL_STYLE.stroke : orig.stroke);
    el.attr('body/strokeWidth', on ? __SEL_STYLE.strokeWidth : orig.strokeWidth);
    el.attr('body/fill', on ? __SEL_STYLE.fill : orig.fill);
  }

  function clearBlockSelection() {
    graph.getElements().forEach(el => __applySelectionStyle(el, false));
  }

  function setSelectedBlocks(ids) {
    clearBlockSelection();
    (ids || []).forEach(id => {
      const el = graph.getCell(String(id));
      if (el) __applySelectionStyle(el, true);
    });
  }


  function renderParamEditor() {
    const info = document.getElementById('selectedInfo');
    const pe = document.getElementById('paramEditor');
    pe.innerHTML = '';

    if (!selectedNodeId) {
      info.textContent = 'Nothing selected.';
      return;
    }
    // Multi-select: show summary and skip param editor
    if (selectedNodeIds && selectedNodeIds.size > 1) {
      const ids = Array.from(selectedNodeIds).map(String).sort((a,b)=>parseInt(a,10)-parseInt(b,10));
      info.innerHTML = `<div><b>${ids.length} blocks selected</b><br>` + ids.map(id => ('#' + id)).join(', ') + `</div>`;
      pe.innerHTML = `<div class="hint">V√≠cen√°sobn√Ω v√Ωbƒõr: editace parametr≈Ø je vypnut√°. Klikni na jeden blok pro editaci.</div>`;
      return;
    }


    const node = graph.getCell(String(selectedNodeId));
    if (!node) {
      selectedNodeId = null;
      info.textContent = 'Nothing selected.';
      return;
    }

    const type = node.get('blockType');
    const spec = BLOCK_LIBRARY[type];
    const params = node.get('params') || {};

    info.innerHTML = `<div><b>ID:</b> ${selectedNodeId} <br><b>Type:</b> ${escapeHtml(type)}</div>`;

    const defaults = (spec && spec.defaultParams) ? spec.defaultParams : {};
    const keys = Object.keys(defaults);

    if (!keys.length) {
      pe.innerHTML = `<div class="hint">No params for this block.</div>`;
      return;
    }

    keys.forEach((k) => {
      const row = document.createElement('div');
      row.className = 'kv';
      const lab = document.createElement('label');
      lab.textContent = k;

      const inp = document.createElement('input');
      const defv = defaults[k];
      const isNum = (typeof defv === 'number');
      inp.type = isNum ? 'number' : 'text';
      if (isNum) inp.step = 'any';
      inp.value = (params[k] !== undefined) ? params[k] : defv;

      const nodeId = String(selectedNodeId);

      const commit = () => {
        const n = graph.getCell(nodeId);
        if (!n) return;

        let newVal;
        if (isNum) {
          const v = parseFloat(inp.value);
          newVal = Number.isFinite(v) ? v : defv;
        } else {
          newVal = inp.value;
        }

        const newParams = { ...(n.get('params') || {}) , [k]: newVal };
        n.set('params', newParams);
        refreshBlockText(nodeId);
      };

      inp.addEventListener('focus', () => { try { inp.select(); } catch(e){} });
      inp.addEventListener('input', commit);
      inp.addEventListener('change', commit);
      inp.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { commit(); inp.blur(); }
      });

      row.appendChild(lab);
      row.appendChild(inp);
      pe.appendChild(row);
    });
  }

  // Click-to-select (single click selects exactly one block)
  paper.on('element:pointerdown', (elementView, evt) => {
    if (evt && evt.stopPropagation) evt.stopPropagation();
    selectedNodeId = String(elementView.model.id);
    selectedNodeIds = new Set([selectedNodeId]);
    setSelectedBlocks(selectedNodeIds);
    renderParamEditor();
  });

  // Left click on blank clears selection (box-select uses DOM handlers below)
  paper.on('blank:pointerdown', (evt) => {
    if (evt && evt.button === 2) return; // RMB reserved for panning
    selectedNodeId = null;
    selectedNodeIds = new Set();
    clearBlockSelection();
    renderParamEditor();
  });

  // Ctrl+R rotates the currently selected block (snap 0/90/180/270)
  function getAngleSnap(a) {
    const n = Math.round(((a % 360) + 360) % 360 / 90) * 90;
    return (n + 360) % 360;
  }
  document.addEventListener('keydown', (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
    const isTyping = (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (e.target && e.target.isContentEditable));
    if (!isTyping && e.ctrlKey && (e.key === 'r' || e.key === 'R')) {
      e.preventDefault();
      if (!selectedNodeId) return;
      const el = graph.getCell(String(selectedNodeId));
      if (!el) return;
      const cur = el.angle() || 0;
      el.rotate(getAngleSnap(cur + 90), true);
      updateLabelUpright(el);
      // link reroute
      graph.getConnectedLinks(el).forEach(l => l.router('manhattan', { step: 20, padding: 12 }));
    }
  });

  // ===== Link behavior: enforce 1 wire per input =====
  function enforceOneWirePerInput(link) {
    const tgt = link.get('target') || {};
    if (!tgt.id || !tgt.port) return;
    const targetEl = graph.getCell(String(tgt.id));
    if (!targetEl) return;
    if (targetEl.get('blockType') === 'Plot') {
      // Plot input also should be single
    }
    const inbound = graph.getConnectedLinks(targetEl, { inbound: true });
    const samePort = inbound.filter(l => l.id !== link.id && (l.get('target') || {}).port === tgt.port);
    samePort.forEach(l => l.remove());
  }

  // Refresh Plot auto-labels after topology changes
  function refreshAllPlotNodeLabels() {
    graph.getElements().forEach(el => {
      if (el.get('blockType') === 'Plot') {
        // Auto-fill label if empty
        const p = el.get('params') || {};
        const curLabel = (typeof p.label === 'string') ? p.label.trim() : '';
        const sig = computePlotSignalPretty(el.id) || '';
        if (!curLabel && sig) {
          el.set('params', { ...p, label: sig });
        }
        refreshBlockText(el.id);
      }
    });
  }

  paper.on('link:connect', (linkView, evt, elementViewConnected, magnet, arrowhead) => {
    const link = linkView.model;
    if (arrowhead === 'target') {
      enforceOneWirePerInput(link);
      refreshAllPlotNodeLabels();
    }
  });
  paper.on('link:disconnect', () => refreshAllPlotNodeLabels());

  // ===== Hover highlight (ports OR links) + click selection for links =====
  let selectedLinkId = null;

  // ===== Variant B: Drag wire segment anywhere (auto-creates/moves a vertex) =====
  // How it works:
  // - Mousedown on a link path creates a vertex at the cursor (or picks a nearby one)
  // - Mousemove updates that vertex position
  // - Mouseup ends the drag
  let __wireDrag = null; // { linkId, vIndex }
  const __WIRE_VERTEX_PICK_PX = 14;

  function __findNearestVertexIndex(link, pLocal) {
    const vs = link.vertices() || [];
    if (!vs.length) return -1;
    let best = -1;
    let bestD2 = Infinity;
    for (let i = 0; i < vs.length; i++) {
      const dx = vs[i].x - pLocal.x;
      const dy = vs[i].y - pLocal.y;
      const d2 = dx*dx + dy*dy;
      if (d2 < bestD2) { bestD2 = d2; best = i; }
    }
    return (Math.sqrt(bestD2) <= __WIRE_VERTEX_PICK_PX) ? best : -1;
  }

  paper.on('link:pointerdown', (linkView, evt) => {
    // Only start "segment drag" when clicking on the visible link path, not on tools/handles.
    const isPath = evt && evt.target && (evt.target.tagName === 'path' || evt.target.closest && evt.target.closest('path'));
    if (!isPath) return;

    const link = linkView.model;
    const p = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });

    let idx = __findNearestVertexIndex(link, p);
    if (idx < 0) {
      // Create new vertex at cursor position
      const vs = link.vertices() || [];
      vs.push({ x: p.x, y: p.y });
      link.vertices(vs);
      idx = vs.length - 1;
    }

    __wireDrag = { linkId: String(link.id), vIndex: idx };
    evt.preventDefault();
    evt.stopPropagation();
  });

  paper.on('blank:pointerup', () => { __wireDrag = null; });
  paper.on('link:pointerup', () => { __wireDrag = null; });

  paper.on('blank:pointermove', (evt) => {
    if (!__wireDrag) return;
    const link = graph.getCell(__wireDrag.linkId);
    if (!link) { __wireDrag = null; return; }
    const p = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });
    const vs = link.vertices() || [];
    if (__wireDrag.vIndex >= 0 && __wireDrag.vIndex < vs.length) {
      vs[__wireDrag.vIndex] = { x: p.x, y: p.y };
      link.vertices(vs);
    }
    evt.preventDefault();
  });

  const hoverLinks = new Set();

  function clearHover() {
    for (const id of hoverLinks) {
      const l = graph.getCell(id);
      if (l && l.isLink() && id !== selectedLinkId) {
        l.attr('line/strokeWidth', 2.2);
        l.attr('line/filter', null);
      }
    }
    hoverLinks.clear();
  }

  function highlightLinks(links) {
    clearHover();
    links.forEach(l => {
      if (!l) return;
      if (String(l.id) === selectedLinkId) return;
      l.attr('line/strokeWidth', 3.6);
      hoverLinks.add(String(l.id));
    });
  }

  function setSelectedLink(link) {
    // reset old
    if (selectedLinkId) {
      const old = graph.getCell(String(selectedLinkId));
      if (old && old.isLink()) {
        old.attr('line/stroke', '#4a90e2');
        old.attr('line/strokeWidth', 2.2);
      }
    }
    selectedLinkId = link ? String(link.id) : null;
    if (selectedLinkId) {
      const l = graph.getCell(selectedLinkId);
      if (l && l.isLink()) {
        l.attr('line/stroke', '#8b5cf6');
        l.attr('line/strokeWidth', 3.8);
      }
    }
  }

  paper.on('link:pointerdown', (linkView) => {
    if (__wireDrag) return; // don't fight with segment-drag handler
    setSelectedLink(linkView.model);
  });paper.on('blank:pointerclick', () => {
    setSelectedLink(null);
    clearHover();
  });

  // Hover link
  paper.on('link:mouseenter', (linkView) => highlightLinks([linkView.model]));
  paper.on('link:mouseleave', () => clearHover());

  // Hover port (mouseenter on element -> inspect DOM target)
  paper.on('element:mouseenter', (elementView, evt) => {
    const portId = evt && evt.target ? evt.target.getAttribute('port') : null;
    if (!portId) return;
    const el = elementView.model;
    const isOut = (evt.target && evt.target.closest) ? !!evt.target.closest('.joint-port') && (evt.target.getAttribute('port-group') === 'out') : false;

    const links = graph.getConnectedLinks(el, isOut ? { outbound: true } : { inbound: true });
    const filtered = links.filter(l => {
      const s = l.get('source') || {}; const t = l.get('target') || {};
      return isOut ? (s.port === portId) : (t.port === portId);
    });
    if (filtered.length) highlightLinks(filtered);
  });
  paper.on('element:mouseleave', () => clearHover());
  // ===== Public API: addBlock/save/load/exportGraph/simulate =====
  window.addBlock = function addBlock(type) {
    const spec = BLOCK_LIBRARY[type];
    if (!spec) return alert('Unknown type: ' + type);
    const x = 320 + Math.random() * 220;
    const y = 60 + Math.random() * 240;
    const el = createBlockCell(type, x, y);
    refreshAllPlotNodeLabels();
    return el.id;
  };

  window.saveScheme = function saveScheme() {
    const scheme = {
      version: 1,
      nextId,
      elements: graph.getElements().map(el => ({
        id: String(el.id),
        type: el.get('blockType'),
        params: el.get('params') || {},
        x: el.position().x,
        y: el.position().y,
        angle: el.angle() || 0
      })),
      links: graph.getLinks().map(l => ({
        source: l.get('source'),
        target: l.get('target')
      }))
    };

    const json = JSON.stringify(scheme, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'scheme.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  window.loadSchemeFromFile = function loadSchemeFromFile(ev) {
    const file = ev && ev.target ? ev.target.files[0] : null;
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const scheme = JSON.parse(reader.result);
        graph.clear();
        selectedNodeId = null;
        selectedNodeIds = new Set();
        try { clearBlockSelection(); } catch(e) {}

        nextId = Math.max(1, parseInt(scheme.nextId || '1', 10));

        // elements
        const idSet = new Set();
        (scheme.elements || []).forEach(e => {
          const el = createBlockCell(e.type, e.x || 50, e.y || 50, e.params || {}, e.id);
          idSet.add(String(el.id));
          if (typeof e.angle === 'number') el.rotate(getAngleSnap(e.angle), true);
          updateLabelUpright(el);
        });

        // links
        (scheme.links || []).forEach(w => {
          if (!w || !w.source || !w.target) return;
          if (!w.source.id || !w.target.id) return;
          const link = paper.options.defaultLink();
          link.source({ id: String(w.source.id), port: w.source.port });
          link.target({ id: String(w.target.id), port: w.target.port });
          link.addTo(graph);
        });

        // Ensure nextId is above max numeric id present
        const nums = Array.from(idSet).map(s => parseInt(s, 10)).filter(n => Number.isFinite(n));
        const maxId = nums.length ? Math.max(...nums) : 0;
        nextId = Math.max(nextId, maxId + 1);

        refreshAllPlotNodeLabels();
        renderParamEditor();

        // history: snapshot after load
        try { __pushUndoSnapshot(); } catch(e) {}

      } catch (e) {
        alert('Nelze naƒç√≠st sch√©ma: ' + e);
      }
    };
    reader.readAsText(file);
    ev.target.value = '';
  };

  // Export graph in the SAME structure your /simulate endpoint expects
  window.exportGraph = function exportGraph() {
    const blocks = [];
    const wires = [];

    const elems = graph.getElements();

    // blocks (exclude Plot)
    elems.forEach(el => {
      const type = el.get('blockType');
      if (type === 'Plot') return;
      blocks.push({
        id: String(el.id),
        type,
        params: el.get('params') || {},
        ui: { x: el.position().x, y: el.position().y, rotationDeg: getAngleSnap(el.angle() || 0) }
      });
    });

    // plotSignals (Plot scopes)
    const plotSignals = [];
    elems.forEach(el => {
      const type = el.get('blockType');
      if (type !== 'Plot') return;
      const p = el.get('params') || {};
      const lbl = (typeof p.label === 'string') ? p.label : '';

      const inbound = graph.getConnectedLinks(el, { inbound: true });
      const link = inbound.find(l => (l.get('target') || {}).port === 'u');
      if (!link) return;
      const src = link.get('source') || {};
      if (!src.id || !src.port) return;
      const srcEl = graph.getCell(String(src.id));
      if (!srcEl) return;
      if (srcEl.get('blockType') === 'Plot') return;

      plotSignals.push({ plotId: String(el.id), block: String(src.id), port: String(src.port), label: lbl });
    });

    // wires: every link where target is NOT Plot
    graph.getLinks().forEach(l => {
      const src = l.get('source') || {};
      const tgt = l.get('target') || {};
      if (!src.id || !src.port || !tgt.id || !tgt.port) return;
      const srcEl = graph.getCell(String(src.id));
      const tgtEl = graph.getCell(String(tgt.id));
      if (!srcEl || !tgtEl) return;
      if (srcEl.get('blockType') === 'Plot') return;
      if (tgtEl.get('blockType') === 'Plot') return; // exclude Plot from simulation wires

      wires.push({
        from: { block: String(src.id), port: String(src.port) },
        to:   { block: String(tgt.id), port: String(tgt.port) }
      });
    });

    const scopeSignals =
      (plotSignals.length
        ? Array.from(new Map(plotSignals.map(s => [`${s.block}.${s.port}`, { block: s.block, port: s.port }])).values())
        : blocks.filter(b => b.type === 'Integrator').map(b => ({ block: b.id, port: 'y' }))
      );

    const scopes = [{ signals: scopeSignals }];

    const graphOut = { blocks, wires, scopes };
    document.getElementById('jsonOut').textContent = JSON.stringify(graphOut, null, 2);
    return graphOut;
  };
  // Compute a stable signature of the current graph relevant for simulation results.
  function __graphSignature() {
    try {
      const g = window.exportGraph();
      // Avoid huge signature differences due to ordering: exportGraph already emits deterministic arrays in creation order.
      return JSON.stringify(g);
    } catch (e) {
      return null;
    }
  }


  // Map server log keys (e.g., "2.y" or "2(TransferFunction).y") to a clear, human-friendly label like "TF (2).y"
  function prettyLabelForLogKey(k) {
    const s = String(k || '');
    let id = null, port = null, typeHint = null;

    let m = s.match(/^(\d+)\([^)]*\)\.([A-Za-z0-9_]+)$/);
    if (m) { id = m[1]; port = m[2]; }

    if (!id) {
      m = s.match(/^(\d+)\.([A-Za-z0-9_]+)$/);
      if (m) { id = m[1]; port = m[2]; }
    }

    if (!id) {
      m = s.match(/^([A-Za-z0-9_]+)\((\d+)\)\.([A-Za-z0-9_]+)$/);
      if (m) { typeHint = m[1]; id = m[2]; port = m[3]; }
    }

    if (!id || !port) return s;

    const n = graph.getCell(String(id));
    const type = n ? n.get('blockType') : (typeHint || 'Block');
    return `${shortTypeName(type)} (${id}).${port}`;
  }

  window.simulate = async function simulate() {
    const graphPayload = window.exportGraph();
    const t0 = parseFloat(document.getElementById('t0').value);
    const t1 = parseFloat(document.getElementById('t1').value);
    const dt = parseFloat(document.getElementById('dt').value);

    const payload = { graph: graphPayload, t0, t1, dt };

    try { toggleOutput(true); } catch(e) {}
    document.getElementById('out').textContent = 'Running...';
    if (typeof Plotly !== 'undefined') { try { Plotly.purge('plot'); } catch(e){} }

    try {
      const res = await fetch('/simulate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      let raw = '';
      try { raw = await res.text(); } catch(e) { raw = ''; }

      if (!res.ok) {
        const ct = res.headers.get('content-type') || '';
        document.getElementById('out').textContent =
          `HTTP ${res.status} ${res.statusText}\ncontent-type: ${ct}\n\n` + (raw || '(empty response)');
        return;
      }

      let data;
      try {
        data = JSON.parse(raw);
        __lastSim = data;
        __lastSimSig = __graphSignature();
      } catch(e) {
        document.getElementById('out').textContent = 'OK response but not JSON:\n' + raw;
        return;
      }

      const keys = Object.keys(data.logs || {});
      if (keys.length && typeof Plotly !== 'undefined') {
        const traces = keys.map(k => ({ x: data.t, y: data.logs[k], mode: 'lines', name: prettyLabelForLogKey(k) }));
        Plotly.newPlot('plot', traces, { title: 'Simulation results', xaxis: { title: 't' }, yaxis: { title: 'value' } }, { responsive: true });
        document.getElementById('out').textContent = `success=${data.success}\nmessage=${data.message}`;
      } else {
        let msg = `success=${data.success}\nmessage=${data.message}\n`;
        if (keys.length) {
          const k = keys[0];
          msg += `first log: ${k}\nfirst 5: ${data.logs[k].slice(0,5).join(', ')}\nlast: ${data.logs[k].slice(-1)[0]}`;
        } else {
          msg += 'No logs.';
        }
        document.getElementById('out').textContent = msg;
      }

      refreshAllPlotNodeLabels();

    } catch(e) {
      document.getElementById('out').textContent = 'Fetch failed: ' + e;
    }
  };

  // ===== Double-click on Plot block: open its own plot window =====
  function openPlotForPlotNode(plotNodeId) {
    const el = graph.getCell(String(plotNodeId));
    if (!el) return;

    const p = el.get('params') || {};
    const label = (typeof p.label === 'string' && p.label.trim()) ? p.label.trim() : `Plot ${plotNodeId}`;

    const titleEl = document.getElementById('plotTitle');
    if (titleEl) titleEl.textContent = label;

    // If we have no simulation yet OR the graph has changed since last simulation, re-run simulate first.
    const curSig = __graphSignature();
    if (!__lastSim || !__lastSim.t || !__lastSim.logs || !__lastSimSig || (curSig && __lastSimSig !== curSig)) {
      try { toggleOutput(true); } catch(e) {}
      window.simulate().then(() => setTimeout(() => openPlotForPlotNode(plotNodeId), 0));
      return;
    }

    const keys = Object.keys(__lastSim.logs || {});
    if (!keys.length) return;

    // Resolve which signal belongs to THIS Plot block (based on its input link)
    const inbound = graph.getConnectedLinks(el, { inbound: true });
    const link = inbound.find(l => (l.get('target') || {}).port === 'u');

    let key = keys[0];
    let pretty = '';
    let foundKey = false;

    if (link) {
      const src = link.get('source') || {};
      const srcId = String(src.id || '');
      const port = String(src.port || 'y');

      const srcEl = graph.getCell(srcId);
      const srcType = srcEl ? srcEl.get('blockType') : '';

      const candidates = [
        `${srcId}(${srcType}).${port}`,
        `${srcId}.${port}`,
        `${srcType}(${srcId}).${port}`,
        `${srcType}${srcId}.${port}`,
        `${srcId}:${port}`,
      ];
      for (const cand of candidates) {
        if (Object.prototype.hasOwnProperty.call(__lastSim.logs, cand)) { key = cand; foundKey = true; break; }
      }

      const re1 = new RegExp(`^${srcId}\\([^)]*\\)\\.${port}$`);
      for (const k of keys) if (re1.test(k)) { key = k; foundKey = true; break; }

      pretty = `${shortTypeName(srcType)} (${srcId}).${port}`;
    }

    // If this Plot was added/rewired after the last simulation, its signal might not exist in logs yet.
    // In that case, re-run simulate and reopen instead of showing a wrong (default) trace.
    if (link && !foundKey) {
      try { toggleOutput(true); } catch(e) {}
      window.simulate().then(() => setTimeout(() => openPlotForPlotNode(plotNodeId), 0));
      return;
    }

    const metaEl = document.getElementById('plotMeta');
    if (metaEl) {
      const txt = pretty ? ((pretty === key) ? `Signal: ${pretty}` : `Signal: ${pretty}  (log key: ${key})`) : `Signal log key: ${key}`;
      metaEl.textContent = txt;
    }

    togglePlotWindow(true);
    if (typeof Plotly !== 'undefined') {
      Plotly.newPlot(
        'plotCanvas',
        [{ x: __lastSim.t, y: __lastSim.logs[key], mode: 'lines', name: (pretty || prettyLabelForLogKey(key) || key) }],
        { title: label, xaxis: { title: 't' }, yaxis: { title: 'value' } },
        { responsive: true }
      );
    }
  }

  paper.on('element:pointerdblclick', (elementView) => {
    const el = elementView.model;
    if (el && el.get('blockType') === 'Plot') openPlotForPlotNode(String(el.id));
  });

  // ===== Auto-load default model on load (from default_scheme.json) =====
(async () => {
  try {
    // Uprav si cestu podle toho, kde soubor ve Flasku opravdu serv√≠ruje≈°.
    // Typicky: /static/default_scheme.json
    const res = await fetch('/static/default_scheme.json', { cache: 'no-store' });
    if (!res.ok) throw new Error(`Failed to load default_scheme.json (${res.status})`);

    const scheme = await res.json();

    // 1) Vytvo≈ô bloky a udƒõlej mapov√°n√≠ p≈Øvodn√≠ID -> nov√°ID
    const idMap = new Map();

    for (const el of (scheme.elements || [])) {
      const cell = createBlockCell(el.type, el.x, el.y, el.params || {});
      idMap.set(String(el.id), String(cell.id));

      // pokud podporuje≈° rotaci:
      if (typeof el.angle === 'number' && cell && typeof cell.rotate === 'function') {
        cell.rotate(getAngleSnap(el.angle), true);
      } else if (typeof el.angle === 'number' && cell) {
        // fallback: nƒõkter√© implementace maj√≠ p≈ô√≠mo atribut angle
        try { cell.set('angle', el.angle); } catch (e) {}
      }
    }

    // 2) Vytvo≈ô linky (ignorujeme magnety, d≈Øle≈æit√© jsou id+port)
    for (const ln of (scheme.links || [])) {
      const srcOld = String(ln.source?.id ?? '');
      const tgtOld = String(ln.target?.id ?? '');
      const srcId  = idMap.get(srcOld);
      const tgtId  = idMap.get(tgtOld);

      if (!srcId || !tgtId) {
        console.warn('Skipping link (missing mapped ids):', ln);
        continue;
      }

      const link = paper.options.defaultLink();
      link.source({ id: srcId, port: ln.source.port });
      link.target({ id: tgtId, port: ln.target.port });
      link.addTo(graph);
    }

    refreshAllPlotNodeLabels();
    setStatus('Default scheme loaded: default_scheme.json');

    // history: snapshot after default model creation
    try { __pushUndoSnapshot(); } catch (e) {}

  } catch (e) {
    setStatus('JS ERROR while auto-loading default scheme: ' + e);
    console.error(e);
  }

  setStatus('Editor started.');
})();
});

</script>
</body>
</html>
