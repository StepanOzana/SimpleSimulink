<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulink-lite (Plain HTML) - JointJS</title>

  <!-- JointJS (UMD, no build step) -->
  <link rel="stylesheet" href="/static/joint.css">
  <script src="/static/joint.js"></script>

  <!-- Plotly (kept as in your Drawflow version) -->
  <script src="/static/plotly-3.3.0.min.js"></script>

  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    .layout { display: grid; grid-template-columns: 260px 1fr; height: 100vh; }
    .panel { border-right: 1px solid #ddd; padding: 12px; overflow: auto; }
    #paperWrap { width: 100%; height: 100%; background: #f6f7f9; outline: none; position: relative; }
    .toolbar button { width: 100%; margin: 6px 0; padding: 10px; cursor: pointer; }
    .blockbtn { text-align: left; }
    .kv { display: grid; grid-template-columns: 70px 90px; gap: 8px; }
    .kv label { font-size: 12px; color: #555; }
    input[type="number"], input[type="text"] { width: 100%; padding: 6px; }
    pre { white-space: pre-wrap; word-break: break-word; background:#111; color:#ddd; padding:10px; border-radius:8px; }
    .hint { font-size: 12px; color:#666; line-height: 1.4; }

    /* Floating panels (Output + Plot) */
    .floating-panel {
      position: fixed;
      top: 60px;
      right: 18px;
      width: 360px;
      max-height: calc(100vh - 90px);
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.18);
      z-index: 9999;
      display: none;
      overflow: hidden;
    }
    .floating-panel.show { display: block; }

    .fp-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      cursor: move;
      user-select:none;
      background:#f3f4f6;
      border-bottom:1px solid #e5e7eb;
      font-weight:700;
    }
    .fp-header .fp-actions{ display:flex; gap:8px; }
    .fp-btn{
      border:1px solid #d1d5db;
      background:#fff;
      border-radius:10px;
      padding:6px 10px;
      cursor:pointer;
      font-weight:600;
    }
    .fp-btn:hover{ background:#f9fafb; }

    .fp-body{
      padding:12px;
      overflow:auto;
      max-height: calc(100vh - 150px);
    }

    /* Plot window is wider */
    #plotWindow.floating-panel{ width: 560px; }
    #plotCanvas{ height: 360px; }

    /* Left panel selection editor */
    .section-title{ margin: 14px 0 8px; font-size: 14px; font-weight: 800; }

    /* Collapsible block categories */
    .blockcats details.cat { margin: 6px 0; }
    .blockcats details.cat summary { cursor: pointer; user-select: none; font-weight: 600; }
    .blockcats details.cat summary::-webkit-details-marker { display: none; }
    .blockcats details.cat summary::before { content: "‚ñæ"; display: inline-block; width: 18px; }
    .blockcats details.cat:not([open]) summary::before { content: "‚ñ∏"; }
    .blockcats details.cat .toolbar { margin-top: 6px; }

    /* JointJS paper tweaks */
    #paperWrap .joint-paper { background: transparent !important; }
    /* Make ports sit above links */
    .joint-port-body { pointer-events: all; }

  
/* === UX: small crosshair cursor on ports / nodes === */
.joint-port,
.joint-port * {
    cursor: crosshair !important;
}

.joint-element {
    cursor: default;
}

.joint-element .joint-port {
    cursor: crosshair;
}


/* Ensure the larger invisible port hit area can capture pointer events */
.joint-port-hit { pointer-events: all; }


/* Keep port hit-ring invisible even when JointJS applies magnet highlighting */
.joint-port-hit,
.joint-port-hit * {
    stroke: transparent !important;
    fill: none !important;
}

</style>
</head>
<body>
<div class="layout">
  <!-- Left panel -->
  <div class="panel">
    <h3>Blocks</h3>
    <div class="blockcats">
      <details class="cat">
        <summary>Sources</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('Constant')">+ Constant</button>
        </div>
      </details>

      <details class="cat">
        <summary>Math</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('Gain')">+ Gain</button>
          <button class="blockbtn" onclick="addBlock('Sum')">+ Sum (u1,u2)</button>
        </div>
      </details>

      <details class="cat">
        <summary>Models</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('TransferFunction')">+ Transfer Function</button>
          <button class="blockbtn" onclick="addBlock('Integrator')">+ Integrator</button>
        </div>
      </details>

      <details class="cat">
        <summary>Sinks</summary>
        <div class="toolbar">
          <button class="blockbtn" onclick="addBlock('Plot')">+ Plot</button>
        </div>
      </details>
    </div>

    <hr>

    <h3>Sch√©ma</h3>
    <button onclick="saveScheme()">üíæ Ulo≈æit sch√©ma</button>
    <input type="file" id="loadSchemeInput" accept="application/json" style="display:none" onchange="loadSchemeFromFile(event)">
    <button onclick="document.getElementById('loadSchemeInput').click()">üìÇ Otev≈ô√≠t sch√©ma</button>

    <hr>

    <h3>Run</h3>
    <div class="kv">
      <label>t0</label><input id="t0" type="number" value="0" step="0.1">
      <label>t1</label><input id="t1" type="number" value="5" step="0.1">
      <label>dt</label><input id="dt" type="number" value="0.1" step="0.01">
    </div>

    <div class="section-title">Selected block</div>
    <div id="selectedInfo" class="hint">Nothing selected.</div>
    <div id="paramEditor"></div>

    <button onclick="exportGraph()">Export JSON</button>
    <button onclick="simulate()">Simulate</button>
    <button id="toggleOutputBtn" style="margin-top:10px;" onclick="toggleOutput()">Show Output (F2)</button>

    <p class="hint">
      Tip: Klikni na blok pro editaci parametr≈Ø vlevo. Propoj porty ta≈æen√≠m z v√Ωstupu do vstupu.
      <br><br>
      MVP pravidla: 1 dr√°t na 1 vstup. ≈Ω√°dn√© ƒçistƒõ algebraick√© cykly.
    </p>
  </div>

  <!-- Canvas -->
  <div id="paperWrap" tabindex="0"></div>
</div>

<!-- Floating Output Panel (toggle with button/F2) -->
<div id="outputWindow" class="floating-panel" aria-hidden="true">
  <div class="fp-header" id="outputHeader">
    <span>Output</span>
    <div class="fp-actions">
      <button class="fp-btn" onclick="toggleOutput(false)">Close</button>
    </div>
  </div>
  <div class="fp-body">
    <div id="jsStatus" class="hint">JS not started yet.</div>
    <div id="plot" style="height:240px;"></div>
    <div id="out" class="hint">‚Äî</div>
    <h4>Last exported JSON</h4>
    <pre id="jsonOut">{}</pre>
  </div>
</div>

<!-- Floating Plot Window (opened by double-click on Plot block) -->
<div id="plotWindow" class="floating-panel" aria-hidden="true">
  <div class="fp-header" id="plotHeader">
    <span id="plotTitle">Plot</span>
    <div class="fp-actions">
      <button class="fp-btn" onclick="togglePlotWindow(false)">Close</button>
    </div>
  </div>
  <div class="fp-body">
    <div id="plotCanvas"></div>
    <div id="plotMeta" class="hint" style="margin-top:8px;"></div>
  </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  const jsStatusEl = document.getElementById('jsStatus');
  const setStatus = (t) => { if (jsStatusEl) jsStatusEl.textContent = t; };

  // ===== Floating window helpers =====
  function toggleOutput(force) {
    const w = document.getElementById('outputWindow');
    const btn = document.getElementById('toggleOutputBtn');
    if (!w) return;
    const show = (typeof force === 'boolean') ? force : !w.classList.contains('show');
    w.classList.toggle('show', show);
    w.setAttribute('aria-hidden', show ? 'false' : 'true');
    if (btn) btn.textContent = show ? 'Hide Output (F2)' : 'Show Output (F2)';
  }

  function togglePlotWindow(force) {
    const w = document.getElementById('plotWindow');
    if (!w) return;
    const show = (typeof force === 'boolean') ? force : !w.classList.contains('show');
    w.classList.toggle('show', show);
    w.setAttribute('aria-hidden', show ? 'false' : 'true');
    if (!show && typeof Plotly !== 'undefined') { try { Plotly.purge('plotCanvas'); } catch(e){} }
  }

  window.toggleOutput = toggleOutput;
  window.togglePlotWindow = togglePlotWindow;

  function makeDraggable(winEl, headerEl) {
    let dragging = false, startX = 0, startY = 0, origX = 0, origY = 0;

    const onDown = (e) => {
      if (e.target && e.target.closest && e.target.closest('button')) return;
      dragging = true;
      const r = winEl.getBoundingClientRect();
      origX = r.left; origY = r.top;
      startX = e.clientX; startY = e.clientY;
      winEl.style.left = origX + 'px';
      winEl.style.top = origY + 'px';
      winEl.style.right = 'auto';
      e.preventDefault();
    };

    const onMove = (e) => {
      if (!dragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      winEl.style.left = (origX + dx) + 'px';
      winEl.style.top  = (origY + dy) + 'px';
    };

    const onUp = () => { dragging = false; };

    headerEl.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }

  // F2 toggles Output window
  document.addEventListener('keydown', (e) => {
    if (e.key === 'F2') {
      e.preventDefault();
      toggleOutput();
    }
  });

  setTimeout(() => {
    const ow = document.getElementById('outputWindow');
    const oh = document.getElementById('outputHeader');
    const pw = document.getElementById('plotWindow');
    const ph = document.getElementById('plotHeader');
    if (ow && oh) makeDraggable(ow, oh);
    if (pw && ph) makeDraggable(pw, ph);
    toggleOutput(false);
    togglePlotWindow(false);
  }, 0);

  // Store last simulation response for Plot double-click
  let __lastSim = null;

  window.onerror = function(msg, url, line, col, err) {
    setStatus('JS ERROR: ' + msg + ' (line ' + line + ')');
  };

  if (typeof joint === 'undefined' || !joint.dia) {
    setStatus('JointJS is NOT defined. Check CDN availability.');
    return;
  }

  setStatus('JS started. Initializing JointJS editor...');

  // ---- Block library: ports + default params ----
  const BLOCK_LIBRARY = {
    Constant:   { inputs: [], outputs: ['y'], defaultParams: { value: 1.0 }, desc: 'constant source' },
    Gain:       { inputs: ['u'], outputs: ['y'], defaultParams: { k: 1.0 }, desc: 'multiply input' },
    Sum:        { inputs: ['u1','u2'], outputs: ['y'], defaultParams: { signs: '++' }, desc: 'sum inputs' },
    Integrator: { inputs: ['u'], outputs: ['y'], defaultParams: { x0: 0.0 }, desc: '‚à´ u dt' },
    Plot:       { inputs: ['u'], outputs: [], defaultParams: { label: '' }, desc: 'signal scope' },
    TransferFunction: { inputs: ['u'], outputs: ['y'], defaultParams: { num: '1', den: '1,1' }, desc: 'continuous LTI system' },
  };

  // ---- Short display names (canvas titles) ----
  const SHORT_NAMES = {
    Constant: 'Const',
    TransferFunction: 'TF',
    Integrator: 'Int',
    Gain: 'Gain',
    Sum: 'Sum',
    Plot: 'Plot'
  };
  function shortTypeName(type) { return SHORT_NAMES[type] || type; }

  // ===== JointJS graph + paper =====
  const namespace = joint.shapes;
  const graph = new joint.dia.Graph({}, { cellNamespace: namespace });

  const wrap = document.getElementById('paperWrap');
  const paper = new joint.dia.Paper({
    el: wrap,
    model: graph,
    gridSize: 20,
    drawGrid: true,
    async: true,
    background: { color: 'transparent' },
    cellViewNamespace: namespace,
    defaultLink: () => {
      const l = new joint.shapes.standard.Link();
      l.attr({
        line: {
          stroke: '#4a90e2',
          strokeWidth: 2.2,
          targetMarker: { type: 'path', d: 'M 10 -5 0 0 10 5 z' }
        }
      });
      l.router('manhattan', { step: 20, padding: 12 });
      l.connector('rounded', { radius: 8 });
      return l;
    },
    interactive: function(cellView) {
      // allow moving elements and manipulating links
      if (cellView.model.isLink()) return { vertexAdd: false };
      return true;
    },
    linkPinning: false,
    snapLinks: { radius: 30 },
    markAvailable: true
  });
  // === Port positioning: tangent to block edge (circle edge touches the block edge) ===
  // We keep the visual port radius = 7, but shift the port CENTER inward by 7px.
  const PORT_RADIUS = 7;     // must match portBody r
  const PORT_INSET  = PORT_RADIUS;

  function leftInsetPositioner(ports, elBBox /*, opt */) {
    const n = ports.length || 1;
    const pad = 14; // vertical padding inside the block
    const h = Math.max(1, elBBox.height - 2 * pad);
    return ports.map((p, i) => ({
      x: elBBox.x - PORT_INSET,
      y: elBBox.y + pad + (n === 1 ? h / 2 : (h * i) / (n - 1))
    }));
  }

  function rightInsetPositioner(ports, elBBox /*, opt */) {
    const n = ports.length || 1;
    const pad = 14;
    const h = Math.max(1, elBBox.height - 2 * pad);
    return ports.map((p, i) => ({
      x: elBBox.x + elBBox.width + PORT_INSET,
      y: elBBox.y + pad + (n === 1 ? h / 2 : (h * i) / (n - 1))
    }));
  }


  function fitPaper() {
    const r = wrap.getBoundingClientRect();
    paper.setDimensions(r.width, r.height);
  }
  window.addEventListener('resize', fitPaper);
  fitPaper();

  // ===== Ports config =====
  const PORT_MARKUP = [
    // Larger invisible hit area so the user can reliably start a connection
    { tagName: 'circle', selector: 'portHit', attributes: { r: 7, fill: 'none', stroke: 'transparent', 'stroke-width': 18, 'pointer-events': 'stroke', class: 'joint-port-hit' } },
    { tagName: 'circle', selector: 'portBody', attributes: { r: 7, class: 'joint-port-body' } },
    // Let clicks go through the text to the magnet circle(s)
    { tagName: 'text', selector: 'portArrow', attributes: { 'font-size': 11, 'font-weight': 900, 'text-anchor': 'middle', 'y': 4, 'pointer-events': 'none' } }
  ];

  const portGroups = {
    in: {
      position: leftInsetPositioner,

      attrs: {
        portHit: { magnet: 'passive' },
        portBody: { fill: '#f5a3c7', stroke: '#d86aa0', magnet: 'passive' },
        portArrow: { text: '‚ñ∂', fill: '#000', x: 0 }
      },
      markup: PORT_MARKUP,
      label: { position: { name: 'left', args: { y: 0 } }, markup: [] }
    },
    out: {
      position: rightInsetPositioner,

      attrs: {
        portHit: { magnet: true },
        portBody: { fill: '#9ecbff', stroke: '#4a90e2', magnet: true },
        portArrow: { text: '‚ñ∂', fill: '#000', x: 0 }
      },
      markup: PORT_MARKUP,
      label: { position: { name: 'right', args: { y: 0 } }, markup: [] }
    }
  };

  // ===== Node HTML (kept: title + desc + paramsLine) =====
  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#039;');
  }

  function formatParamsLine(type, params, meta) {
    const spec = BLOCK_LIBRARY[type] || {};
    const defaults = spec.defaultParams || {};

    if (type === 'Plot') {
      const sig = (meta && meta.signalPretty) ? String(meta.signalPretty) : '';
      const lbl = (params && typeof params.label === 'string') ? params.label.trim() : '';
      if (lbl && sig && lbl !== sig) return `${lbl} ‚Äî ${sig}`;
      if (lbl) return lbl;
      if (sig) return sig;
      return '(not connected)';
    }
    if (type === 'Constant')   return `value=${(params && params.value !== undefined) ? params.value : defaults.value}`;
    if (type === 'Gain')       return `k=${(params && params.k !== undefined) ? params.k : defaults.k}`;
    if (type === 'Sum')        return `signs=${(params && params.signs !== undefined) ? params.signs : defaults.signs}`;
    if (type === 'Integrator') return `x0=${(params && params.x0 !== undefined) ? params.x0 : defaults.x0}`;
    if (type === 'TransferFunction') {
      const num = (params && params.num !== undefined) ? params.num : defaults.num;
      const den = (params && params.den !== undefined) ? params.den : defaults.den;
      return `num=${num}, den=${den}`;
    }

    const parts = [];
    for (const k of Object.keys(defaults)) {
      const cur = (params && params[k] !== undefined) ? params[k] : defaults[k];
      parts.push(`${k}=${cur}`);
    }
    return parts.join(', ');
  }

  function computePlotSignalPretty(plotId) {
    const plotEl = graph.getCell(String(plotId));
    if (!plotEl) return '';

    // incoming link to Plot.u
    const inbound = graph.getConnectedLinks(plotEl, { inbound: true });
    const link = inbound.find(l => (l.get('target') || {}).port === 'u');
    if (!link) return '';

    const src = link.get('source') || {};
    const srcId = String(src.id || '');
    const srcPort = String(src.port || 'y');
    const srcEl = graph.getCell(srcId);
    const srcType = srcEl ? srcEl.get('blockType') : '';

    return `${shortTypeName(srcType)} (${srcId}).${srcPort}`;
  }

  function blockText(type, id, params) {
    const shown = shortTypeName(type);
    const title = `${shown} (${id})`;
    const desc = (BLOCK_LIBRARY[type] && typeof BLOCK_LIBRARY[type].desc === 'string') ? BLOCK_LIBRARY[type].desc : '';

    let sigPretty = '';
    if (type === 'Plot') sigPretty = computePlotSignalPretty(id) || '';
    const line = formatParamsLine(type, params || {}, { signalPretty: sigPretty });

    // Using SVG <text> multiline (\n). JointJS splits lines.
    const parts = [title];
    if (desc) parts.push(desc);
    if (line) parts.push(line);
    return parts.join('\n');
  }

  // ===== Create blocks =====
  let nextId = 1;
  function allocId() { return String(nextId++); }

  function createBlockCell(type, x, y, params, forcedId) {
    const spec = BLOCK_LIBRARY[type];
    if (!spec) throw new Error('Unknown type: ' + type);

    const id = forcedId ? String(forcedId) : allocId();
    const p = params ? JSON.parse(JSON.stringify(params)) : JSON.parse(JSON.stringify(spec.defaultParams));

    const el = new joint.shapes.standard.Rectangle({
      id,
      blockType: type,
      params: p
    });

    el.position(x, y);
    el.resize(170, 76);

    el.attr({
      body: {
        rx: 10, ry: 10,
        stroke: '#b8c0cc',
        strokeWidth: 1.2,
        fill: '#ffffff'
      },
      label: {
        text: blockText(type, id, p),
        fill: '#111',
        fontSize: 12,
        fontFamily: 'Arial, sans-serif',
        textWrap: { width: -10, height: -10 }
      }
    });

    // ports
    el.set('ports', { groups: portGroups, items: [] });
    const inPorts  = spec.inputs.map(name => ({ id: name, group: 'in' }));
    const outPorts = spec.outputs.map(name => ({ id: name, group: 'out' }));
    el.addPorts([...inPorts, ...outPorts]);

    el.addTo(graph);
    return el;
  }

  function refreshBlockText(id) {
    const el = graph.getCell(String(id));
    if (!el || el.isLink()) return;
    const type = el.get('blockType');
    const params = el.get('params') || {};
    el.attr('label/text', blockText(type, String(id), params));
  }

  // ===== Selection + param editor =====
  let selectedNodeId = null;

  function renderParamEditor() {
    const info = document.getElementById('selectedInfo');
    const pe = document.getElementById('paramEditor');
    pe.innerHTML = '';

    if (!selectedNodeId) {
      info.textContent = 'Nothing selected.';
      return;
    }

    const node = graph.getCell(String(selectedNodeId));
    if (!node) {
      selectedNodeId = null;
      info.textContent = 'Nothing selected.';
      return;
    }

    const type = node.get('blockType');
    const spec = BLOCK_LIBRARY[type];
    const params = node.get('params') || {};

    info.innerHTML = `<div><b>ID:</b> ${selectedNodeId} <br><b>Type:</b> ${escapeHtml(type)}</div>`;

    const defaults = (spec && spec.defaultParams) ? spec.defaultParams : {};
    const keys = Object.keys(defaults);

    if (!keys.length) {
      pe.innerHTML = `<div class="hint">No params for this block.</div>`;
      return;
    }

    keys.forEach((k) => {
      const row = document.createElement('div');
      row.className = 'kv';
      const lab = document.createElement('label');
      lab.textContent = k;

      const inp = document.createElement('input');
      const defv = defaults[k];
      const isNum = (typeof defv === 'number');
      inp.type = isNum ? 'number' : 'text';
      if (isNum) inp.step = 'any';
      inp.value = (params[k] !== undefined) ? params[k] : defv;

      const nodeId = String(selectedNodeId);

      const commit = () => {
        const n = graph.getCell(nodeId);
        if (!n) return;

        let newVal;
        if (isNum) {
          const v = parseFloat(inp.value);
          newVal = Number.isFinite(v) ? v : defv;
        } else {
          newVal = inp.value;
        }

        const newParams = { ...(n.get('params') || {}) , [k]: newVal };
        n.set('params', newParams);
        refreshBlockText(nodeId);
      };

      inp.addEventListener('focus', () => { try { inp.select(); } catch(e){} });
      inp.addEventListener('input', commit);
      inp.addEventListener('change', commit);
      inp.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { commit(); inp.blur(); }
      });

      row.appendChild(lab);
      row.appendChild(inp);
      pe.appendChild(row);
    });
  }

  // Click-to-select
  paper.on('element:pointerdown', (elementView) => {
    selectedNodeId = String(elementView.model.id);
    renderParamEditor();
  });
  paper.on('blank:pointerdown', () => {
    selectedNodeId = null;
    renderParamEditor();
  });

  // Ctrl+R rotates the currently selected block (snap 0/90/180/270)
  function getAngleSnap(a) {
    const n = Math.round(((a % 360) + 360) % 360 / 90) * 90;
    return (n + 360) % 360;
  }
  document.addEventListener('keydown', (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
    const isTyping = (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (e.target && e.target.isContentEditable));
    if (!isTyping && e.ctrlKey && (e.key === 'r' || e.key === 'R')) {
      e.preventDefault();
      if (!selectedNodeId) return;
      const el = graph.getCell(String(selectedNodeId));
      if (!el) return;
      const cur = el.angle() || 0;
      el.rotate(getAngleSnap(cur + 90), true);
      // link reroute
      graph.getConnectedLinks(el).forEach(l => l.router('manhattan', { step: 20, padding: 12 }));
    }
  });

  // ===== Link behavior: enforce 1 wire per input =====
  function enforceOneWirePerInput(link) {
    const tgt = link.get('target') || {};
    if (!tgt.id || !tgt.port) return;
    const targetEl = graph.getCell(String(tgt.id));
    if (!targetEl) return;
    if (targetEl.get('blockType') === 'Plot') {
      // Plot input also should be single
    }
    const inbound = graph.getConnectedLinks(targetEl, { inbound: true });
    const samePort = inbound.filter(l => l.id !== link.id && (l.get('target') || {}).port === tgt.port);
    samePort.forEach(l => l.remove());
  }

  // Refresh Plot auto-labels after topology changes
  function refreshAllPlotNodeLabels() {
    graph.getElements().forEach(el => {
      if (el.get('blockType') === 'Plot') {
        // Auto-fill label if empty
        const p = el.get('params') || {};
        const curLabel = (typeof p.label === 'string') ? p.label.trim() : '';
        const sig = computePlotSignalPretty(el.id) || '';
        if (!curLabel && sig) {
          el.set('params', { ...p, label: sig });
        }
        refreshBlockText(el.id);
      }
    });
  }

  paper.on('link:connect', (linkView, evt, elementViewConnected, magnet, arrowhead) => {
    const link = linkView.model;
    if (arrowhead === 'target') {
      enforceOneWirePerInput(link);
      refreshAllPlotNodeLabels();
    }
  });
  paper.on('link:disconnect', () => refreshAllPlotNodeLabels());

  // ===== Hover highlight (ports OR links) + click selection for links =====
  let selectedLinkId = null;
  const hoverLinks = new Set();

  function clearHover() {
    for (const id of hoverLinks) {
      const l = graph.getCell(id);
      if (l && l.isLink() && id !== selectedLinkId) {
        l.attr('line/strokeWidth', 2.2);
        l.attr('line/filter', null);
      }
    }
    hoverLinks.clear();
  }

  function highlightLinks(links) {
    clearHover();
    links.forEach(l => {
      if (!l) return;
      if (String(l.id) === selectedLinkId) return;
      l.attr('line/strokeWidth', 3.6);
      hoverLinks.add(String(l.id));
    });
  }

  function setSelectedLink(link) {
    // reset old
    if (selectedLinkId) {
      const old = graph.getCell(String(selectedLinkId));
      if (old && old.isLink()) {
        old.attr('line/stroke', '#4a90e2');
        old.attr('line/strokeWidth', 2.2);
      }
    }
    selectedLinkId = link ? String(link.id) : null;
    if (selectedLinkId) {
      const l = graph.getCell(selectedLinkId);
      if (l && l.isLink()) {
        l.attr('line/stroke', '#8b5cf6');
        l.attr('line/strokeWidth', 3.8);
      }
    }
  }

  paper.on('link:pointerdown', (linkView) => {
    setSelectedLink(linkView.model);
  });
  paper.on('blank:pointerdown', () => {
    setSelectedLink(null);
    clearHover();
  });

  // Hover link
  paper.on('link:mouseenter', (linkView) => highlightLinks([linkView.model]));
  paper.on('link:mouseleave', () => clearHover());

  // Hover port (mouseenter on element -> inspect DOM target)
  paper.on('element:mouseenter', (elementView, evt) => {
    const portId = evt && evt.target ? evt.target.getAttribute('port') : null;
    if (!portId) return;
    const el = elementView.model;
    const isOut = (evt.target && evt.target.closest) ? !!evt.target.closest('.joint-port') && (evt.target.getAttribute('port-group') === 'out') : false;

    const links = graph.getConnectedLinks(el, isOut ? { outbound: true } : { inbound: true });
    const filtered = links.filter(l => {
      const s = l.get('source') || {}; const t = l.get('target') || {};
      return isOut ? (s.port === portId) : (t.port === portId);
    });
    if (filtered.length) highlightLinks(filtered);
  });
  paper.on('element:mouseleave', () => clearHover());

  // Delete selected link with Delete/Backspace
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
      const isTyping = (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (e.target && e.target.isContentEditable));
      if (isTyping) return;
      if (selectedLinkId) {
        const l = graph.getCell(String(selectedLinkId));
        if (l && l.isLink()) {
          l.remove();
          selectedLinkId = null;
          clearHover();
          refreshAllPlotNodeLabels();
        }
      }
    }
  });

  // ===== Public API: addBlock/save/load/exportGraph/simulate =====
  window.addBlock = function addBlock(type) {
    const spec = BLOCK_LIBRARY[type];
    if (!spec) return alert('Unknown type: ' + type);
    const x = 320 + Math.random() * 220;
    const y = 60 + Math.random() * 240;
    const el = createBlockCell(type, x, y);
    refreshAllPlotNodeLabels();
    return el.id;
  };

  window.saveScheme = function saveScheme() {
    const scheme = {
      version: 1,
      nextId,
      elements: graph.getElements().map(el => ({
        id: String(el.id),
        type: el.get('blockType'),
        params: el.get('params') || {},
        x: el.position().x,
        y: el.position().y,
        angle: el.angle() || 0
      })),
      links: graph.getLinks().map(l => ({
        source: l.get('source'),
        target: l.get('target')
      }))
    };

    const json = JSON.stringify(scheme, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'scheme.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  window.loadSchemeFromFile = function loadSchemeFromFile(ev) {
    const file = ev && ev.target ? ev.target.files[0] : null;
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const scheme = JSON.parse(reader.result);
        graph.clear();

        nextId = Math.max(1, parseInt(scheme.nextId || '1', 10));

        // elements
        const idSet = new Set();
        (scheme.elements || []).forEach(e => {
          const el = createBlockCell(e.type, e.x || 50, e.y || 50, e.params || {}, e.id);
          idSet.add(String(el.id));
          if (typeof e.angle === 'number') el.rotate(getAngleSnap(e.angle), true);
        });

        // links
        (scheme.links || []).forEach(w => {
          if (!w || !w.source || !w.target) return;
          if (!w.source.id || !w.target.id) return;
          const link = paper.options.defaultLink();
          link.source({ id: String(w.source.id), port: w.source.port });
          link.target({ id: String(w.target.id), port: w.target.port });
          link.addTo(graph);
        });

        // Ensure nextId is above max numeric id present
        const nums = Array.from(idSet).map(s => parseInt(s, 10)).filter(n => Number.isFinite(n));
        const maxId = nums.length ? Math.max(...nums) : 0;
        nextId = Math.max(nextId, maxId + 1);

        refreshAllPlotNodeLabels();
        renderParamEditor();
      } catch (e) {
        alert('Nelze naƒç√≠st sch√©ma: ' + e);
      }
    };
    reader.readAsText(file);
    ev.target.value = '';
  };

  // Export graph in the SAME structure your /simulate endpoint expects
  window.exportGraph = function exportGraph() {
    const blocks = [];
    const wires = [];

    const elems = graph.getElements();

    // blocks (exclude Plot)
    elems.forEach(el => {
      const type = el.get('blockType');
      if (type === 'Plot') return;
      blocks.push({
        id: String(el.id),
        type,
        params: el.get('params') || {},
        ui: { x: el.position().x, y: el.position().y, rotationDeg: getAngleSnap(el.angle() || 0) }
      });
    });

    // plotSignals (Plot scopes)
    const plotSignals = [];
    elems.forEach(el => {
      const type = el.get('blockType');
      if (type !== 'Plot') return;
      const p = el.get('params') || {};
      const lbl = (typeof p.label === 'string') ? p.label : '';

      const inbound = graph.getConnectedLinks(el, { inbound: true });
      const link = inbound.find(l => (l.get('target') || {}).port === 'u');
      if (!link) return;
      const src = link.get('source') || {};
      if (!src.id || !src.port) return;
      const srcEl = graph.getCell(String(src.id));
      if (!srcEl) return;
      if (srcEl.get('blockType') === 'Plot') return;

      plotSignals.push({ plotId: String(el.id), block: String(src.id), port: String(src.port), label: lbl });
    });

    // wires: every link where target is NOT Plot
    graph.getLinks().forEach(l => {
      const src = l.get('source') || {};
      const tgt = l.get('target') || {};
      if (!src.id || !src.port || !tgt.id || !tgt.port) return;
      const srcEl = graph.getCell(String(src.id));
      const tgtEl = graph.getCell(String(tgt.id));
      if (!srcEl || !tgtEl) return;
      if (srcEl.get('blockType') === 'Plot') return;
      if (tgtEl.get('blockType') === 'Plot') return; // exclude Plot from simulation wires

      wires.push({
        from: { block: String(src.id), port: String(src.port) },
        to:   { block: String(tgt.id), port: String(tgt.port) }
      });
    });

    const scopeSignals =
      (plotSignals.length
        ? Array.from(new Map(plotSignals.map(s => [`${s.block}.${s.port}`, { block: s.block, port: s.port }])).values())
        : blocks.filter(b => b.type === 'Integrator').map(b => ({ block: b.id, port: 'y' }))
      );

    const scopes = [{ signals: scopeSignals }];

    const graphOut = { blocks, wires, scopes };
    document.getElementById('jsonOut').textContent = JSON.stringify(graphOut, null, 2);
    return graphOut;
  };

  // Map server log keys (e.g., "2.y" or "2(TransferFunction).y") to a clear, human-friendly label like "TF (2).y"
  function prettyLabelForLogKey(k) {
    const s = String(k || '');
    let id = null, port = null, typeHint = null;

    let m = s.match(/^(\d+)\([^)]*\)\.([A-Za-z0-9_]+)$/);
    if (m) { id = m[1]; port = m[2]; }

    if (!id) {
      m = s.match(/^(\d+)\.([A-Za-z0-9_]+)$/);
      if (m) { id = m[1]; port = m[2]; }
    }

    if (!id) {
      m = s.match(/^([A-Za-z0-9_]+)\((\d+)\)\.([A-Za-z0-9_]+)$/);
      if (m) { typeHint = m[1]; id = m[2]; port = m[3]; }
    }

    if (!id || !port) return s;

    const n = graph.getCell(String(id));
    const type = n ? n.get('blockType') : (typeHint || 'Block');
    return `${shortTypeName(type)} (${id}).${port}`;
  }

  window.simulate = async function simulate() {
    const graphPayload = window.exportGraph();
    const t0 = parseFloat(document.getElementById('t0').value);
    const t1 = parseFloat(document.getElementById('t1').value);
    const dt = parseFloat(document.getElementById('dt').value);

    const payload = { graph: graphPayload, t0, t1, dt };

    try { toggleOutput(true); } catch(e) {}
    document.getElementById('out').textContent = 'Running...';
    if (typeof Plotly !== 'undefined') { try { Plotly.purge('plot'); } catch(e){} }

    try {
      const res = await fetch('/simulate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      let raw = '';
      try { raw = await res.text(); } catch(e) { raw = ''; }

      if (!res.ok) {
        const ct = res.headers.get('content-type') || '';
        document.getElementById('out').textContent =
          `HTTP ${res.status} ${res.statusText}\ncontent-type: ${ct}\n\n` + (raw || '(empty response)');
        return;
      }

      let data;
      try {
        data = JSON.parse(raw);
        __lastSim = data;
      } catch(e) {
        document.getElementById('out').textContent = 'OK response but not JSON:\n' + raw;
        return;
      }

      const keys = Object.keys(data.logs || {});
      if (keys.length && typeof Plotly !== 'undefined') {
        const traces = keys.map(k => ({ x: data.t, y: data.logs[k], mode: 'lines', name: prettyLabelForLogKey(k) }));
        Plotly.newPlot('plot', traces, { title: 'Simulation results', xaxis: { title: 't' }, yaxis: { title: 'value' } }, { responsive: true });
        document.getElementById('out').textContent = `success=${data.success}\nmessage=${data.message}`;
      } else {
        let msg = `success=${data.success}\nmessage=${data.message}\n`;
        if (keys.length) {
          const k = keys[0];
          msg += `first log: ${k}\nfirst 5: ${data.logs[k].slice(0,5).join(', ')}\nlast: ${data.logs[k].slice(-1)[0]}`;
        } else {
          msg += 'No logs.';
        }
        document.getElementById('out').textContent = msg;
      }

      refreshAllPlotNodeLabels();

    } catch(e) {
      document.getElementById('out').textContent = 'Fetch failed: ' + e;
    }
  };

  // ===== Double-click on Plot block: open its own plot window =====
  function openPlotForPlotNode(plotNodeId) {
    const el = graph.getCell(String(plotNodeId));
    if (!el) return;

    const p = el.get('params') || {};
    const label = (typeof p.label === 'string' && p.label.trim()) ? p.label.trim() : `Plot ${plotNodeId}`;

    const titleEl = document.getElementById('plotTitle');
    if (titleEl) titleEl.textContent = label;

    if (!__lastSim || !__lastSim.t || !__lastSim.logs) {
      try { toggleOutput(true); } catch(e) {}
      window.simulate().then(() => setTimeout(() => openPlotForPlotNode(plotNodeId), 0));
      return;
    }

    const keys = Object.keys(__lastSim.logs || {});
    if (!keys.length) return;

    // Resolve which signal belongs to THIS Plot block (based on its input link)
    const inbound = graph.getConnectedLinks(el, { inbound: true });
    const link = inbound.find(l => (l.get('target') || {}).port === 'u');

    let key = keys[0];
    let pretty = '';

    if (link) {
      const src = link.get('source') || {};
      const srcId = String(src.id || '');
      const port = String(src.port || 'y');

      const srcEl = graph.getCell(srcId);
      const srcType = srcEl ? srcEl.get('blockType') : '';

      const candidates = [
        `${srcId}(${srcType}).${port}`,
        `${srcId}.${port}`,
        `${srcType}(${srcId}).${port}`,
        `${srcType}${srcId}.${port}`,
        `${srcId}:${port}`,
      ];
      for (const cand of candidates) {
        if (Object.prototype.hasOwnProperty.call(__lastSim.logs, cand)) { key = cand; break; }
      }

      const re1 = new RegExp(`^${srcId}\\([^)]*\\)\\.${port}$`);
      for (const k of keys) if (re1.test(k)) { key = k; break; }

      pretty = `${shortTypeName(srcType)} (${srcId}).${port}`;
    }

    const metaEl = document.getElementById('plotMeta');
    if (metaEl) {
      const txt = pretty ? ((pretty === key) ? `Signal: ${pretty}` : `Signal: ${pretty}  (log key: ${key})`) : `Signal log key: ${key}`;
      metaEl.textContent = txt;
    }

    togglePlotWindow(true);
    if (typeof Plotly !== 'undefined') {
      Plotly.newPlot(
        'plotCanvas',
        [{ x: __lastSim.t, y: __lastSim.logs[key], mode: 'lines', name: (pretty || prettyLabelForLogKey(key) || key) }],
        { title: label, xaxis: { title: 't' }, yaxis: { title: 'value' } },
        { responsive: true }
      );
    }
  }

  paper.on('element:pointerdblclick', (elementView) => {
    const el = elementView.model;
    if (el && el.get('blockType') === 'Plot') openPlotForPlotNode(String(el.id));
  });

  // ===== Auto-create a default model on load (Const -> TF -> Plot) =====
  try {
    const idConst = createBlockCell('Constant', 100, 140, { value: 1.0 }).id;
    const idTF    = createBlockCell('TransferFunction', 380, 140, { num: '1', den: '1,1' }).id;
    const idPlot  = createBlockCell('Plot', 660, 140, { label: '' }).id;

    const l1 = paper.options.defaultLink();
    l1.source({ id: String(idConst), port: 'y' });
    l1.target({ id: String(idTF), port: 'u' });
    l1.addTo(graph);

    const l2 = paper.options.defaultLink();
    l2.source({ id: String(idTF), port: 'y' });
    l2.target({ id: String(idPlot), port: 'u' });
    l2.addTo(graph);

    refreshAllPlotNodeLabels();
    setStatus('Default model added: Constant ‚Üí Transfer Function ‚Üí Plot');

  } catch(e) {
    setStatus('JS ERROR while auto-adding model: ' + e);
    console.error(e);
  }

  setStatus('Editor started.');
});
</script>
</body>
</html>
